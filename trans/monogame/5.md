在声控游戏成为标准之前，游戏开发者必须给玩家一种控制游戏的方法。幸运的是，一夫一妻制可以很容易地将输入设备连接到你的游戏中。在这一章中，我们将构建一个输入系统来识别使用这些设备的玩家，您可以在所有游戏中重复使用这些设备。我们将看看 PC 和游戏机游戏中通常使用的三种设备。移动设备具有触摸形式的附加功能，这是输入的主要来源，但我们只关注前两个平台。如果你想把你的游戏移植到移动平台，你必须在我们这里开发的输入系统中增加触摸功能。

游戏手柄是用于控制台的鼠标和键盘的组合，因为大多数游戏玩家不希望也没有这些设备在他们的客厅或其他通常使用控制台的房间里。游戏手柄也更小，不用时更容易存放。由于输入类型的数量有限，它们没有鼠标和键盘那么灵活，所以你可能不得不在游戏中创造性地使用它们。一种方法是使用屏幕界面元素，如对话框、菜单和工具栏，玩家可以调出或切换来控制他们的角色。

输入设备可以有两种控制:数字和模拟。数字控件只能处于两种状态之一:打开或关闭。键盘上的按键是数字控制的例子，鼠标上的按钮也是，Xbox 360 控制器上的按钮和 DPad 也是。模拟控件可以具有特定范围内的值。Xbox 360 控制器上的操纵杆和触发器以及鼠标的移动在一定范围内返回数值。Xbox 360 控制器返回 1.0 到 1.0 之间的浮点值，触发器返回 0.0 到 1.0 之间的值。对于鼠标，鼠标光标值以像素为单位返回。

每种输入设备都有特定的优点和缺点。下表显示了简单的比较:

| **输入装置** | **数字按钮** | **模拟控制** | **振动效果** | **支持在 Windows 上** | **Xbox 上支持** | **#系统允许** |
| --- | --- | --- | --- | --- | --- | --- |
| Xbox 控制器 | Fourteen | four | 是 | 是 | 是 | four |
| 键盘 | > 100 | Zero | 不 | 是 | 是 | one |
| 老鼠 | five | three | 不 | 是 | 不 | one |

表 3–输入设备平台比较

由于您不能假设电脑上的玩家正在使用特定类型的游戏手柄(甚至是实际的游戏手柄)，`GamePad`类提供了两种称为`GetCapabilities`的方法来获取正在使用的设备上的控件。一种方法采用`int`参数，另一种采用`PlayerIndex`参数。

这些方法返回具有以下属性的`GamePadCapabilities`结构:

| **名称** | **描述** |
| --- | --- |
| `DisplayName` | 获取游戏手柄显示名称。 |
| `GamePadType` | 获取控制器的类型 |
| `HasAButton` | 获取一个值，该值指示控制器是否有按钮 |
| `HasBButton` | 获取一个值，该值指示控制器是否有按钮 B |
| `HasBackButton` | 获取一个值，该值指示控制器是否有“后退”按钮 |
| `HasBigButton` | 获取一个值，该值指示控制器是否有向导按钮 |
| `HasDPadDownButton` | 获取一个值，该值指示控制器是否有方向键盘向下按钮 |
| `HasDPadLeftButton` | 获取一个值，该值指示控制器是否有方向键盘左按钮 |
| `HasDPadRightButton` | 获取一个值，该值指示控制器是否有方向板右按钮 |
| `HasDPadUpButton` | 获取一个值，该值指示控制器是否有方向向上按钮 |
| `HasLeftShoulderButton` | 获取一个值，该值指示控制器是否有左肩按钮 |
| `HasLeftStickButton` | 获取一个值，该值指示控制器是否有左操纵杆按钮 |
| `HasLeftTrigger` | 获取一个值，该值指示控制器是否有左触发器按钮 |
| `HasLeftVibrationMotor` | 获取一个值，该值指示控制器是否有左振动马达 |
| `HasLeftXThumbStick` | 获取一个值，该值指示控制器是否具有左操纵杆(拇指操纵杆)按钮的 X 轴 |
| `HasLeftYThumbStick` | 获取一个值，该值指示控制器是否具有左操纵杆(拇指操纵杆)按钮的 Y 轴 |
| `HasRightShoulderButton` | 获取一个值，该值指示控制器是否有右肩按钮 |
| `HasRightStickButton` | 获取一个值，该值指示控制器是否有右操纵杆按钮 |
| `HasRightTrigger` | 获取一个值，该值指示控制器是否有正确的触发器按钮 |
| `HasRightVibrationMotor` | 获取一个值，该值指示控制器是否有正确的振动马达 |
| `HasRightXThumbStick` | 获取一个值，该值指示控制器是否具有右操纵杆(拇指操纵杆)按钮的 X 轴 |
| `HasRightYThumbStick` | 获取一个值，该值指示控制器是否具有右操纵杆(拇指操纵杆)按钮的 Y 轴 |
| `HasStartButton` | 获取一个值，该值指示控制器是否有“开始”按钮 |
| `HasVoiceSupport` | 获取一个值，该值指示控制器是否有麦克风 |
| `HasXButton` | 获取一个值，该值指示控制器是否有按钮 X |
| `HasYButton` | 获取一个值，该值指示控制器是否有按钮 Y |
| `Identifier` | 获取游戏手柄的唯一标识符。 |
| `IsConnected` | 获取指示控制器是否已连接的值 |

表 4–游戏平台功能结构属性

如果您要支持任何类型的控制器，您需要检查`GamePadType`属性，以确保您想要使用的任何控制器都在玩家正在使用的控制器上得到支持。如果您的游戏属于需要特定类型控制器的类型，例如音乐或节奏游戏，或者玩家可以使用飞行棒的飞机模拟器或飞行游戏，您也需要检查这一点。`GamePadType`的可能值为:

| **名称** | **描述** |
| --- | --- |
| `AlternateGuitar` | 游戏手柄是一种替代吉他 |
| `ArcadeStick` | 游戏手柄是一个街机操纵杆 |
| `BigButtonPad` | 游戏手柄是一个大按钮手柄 |
| `DancePad` | 游戏垫是一个舞蹈垫 |
| `DrumKit` | 游戏手柄是一个鼓包 |
| `FlightStick` | 游戏手柄是一个飞行棒 |
| `GamePad` | 游戏手柄是 XBOX 控制器 |
| `Guitar` | 游戏手柄是一把吉他 |
| `Unknown` | 未知的 |
| `Wheel` | 游戏手柄是一个轮子 |

表 5–游戏面板类型字段

`BigButtonPad`是微软随“场景 It”推出的一款特定类型的控制器对智力竞赛类游戏有用的游戏。它顶部有一个大按钮，充当蜂鸣器，还有四个小按钮，用于回答选择题。

如果你的游戏使用振动马达，你将使用两种`SetVibration`方法来控制它们。这些方法采用三个参数，第一个是`PlayerIndex`或`int`，另外两个是浮点数。

有四种`GetState`方法，尽管您可能只使用两种带有`PlayerIndex`或`int`参数的方法。另外两个采用对模拟操纵杆控制器有用的`GamePadDeadZone`参数。

每一帧，可用输入设备的状态都被更新，并通过各种结构变得可用。我们首先要看的是包含游戏手柄数据的结构。`GamePadState`结构为我们提供了以下控件的状态以及获取其中一些控件的方法:

| **属性** |
| `Buttons` |
| `DPad` |
| `IsConnected` |
| `ThumbSticks` |
| `Triggers` |
| **方法** |
| `IsButtonDown` |
| `IsButtonUp` |

表 6–游戏状态结构属性和方法

该结构提供了比这更多的属性和方法，但这些是最常用的。

代表游戏手柄上各种控件的属性本身就是包含该属性的各种选项的属性的结构。按钮包含所有基本控件:A/B/X/Y 按钮、后退/开始按钮和肩膀/棍子。该结构中的每个属性都是一个值为`Pressed`或`Released`的枚举。

`DPad`具有`Left`、`Right`、`Up`和`Down`属性，这些属性可以是`Pressed`或`Released`。

`Triggers`和`ThumbSticks`分别为`Left`和`Right`控件使用`float`和`Vector2`数据类型，因为它们不必完全按下或释放。这些提供了`Button`特性所不具备的细节。如果你使用这两种方式，你只需要知道它们是否被按下，使用`Buttons`属性。例如，这可以用于导航用户界面。你不需要知道控件被按了多远，只需要知道它是否被按了。如果是，您可能会移动到可以选择的下一个用户界面元素。如果你用拇指棒来控制一个角色，你需要知道它朝哪个方向移动，可能移动多少。

`IsButtonUp`和`IsButtonDown`方法采用一个`Buttons`枚举参数，并返回一个布尔值来指示按钮(该参数可以是按位“或”来同时检查多个按钮)是否被按下或释放。如果你有一个使用按钮组合来执行动作的游戏，这很有用，而且比单独检查每个按钮更容易。

`Keyboard`类只包含两个方法，用于获取键盘的状态。第一个不带参数，返回当前键盘的状态。第二个参数取`PlayerIndex`参数，返回特定玩家的键盘状态。然而，这种方法已经过时，因此应该避免使用。

`KeyboardState`结构有三个属性，你可能不会经常使用，还有三个方法，这可能是你最常依赖的。

| **属性** | **描述** |
| CapsLock | 返回顶点锁密钥的当前状态 |
| 项目 | 返回特定键的当前状态 |
| NumLock | 返回 NumLock 键的当前状态 |
| **方法** | **描述** |
| GetPressedKeys | 返回当前按下的键的数组 |
| IsKeyDown | 返回一个布尔值，该值指示是否按下了指定的键 |
| IsKeyUp | 返回一个布尔值，该值指示指定的键是否未被按下 |

表 7–键盘状态结构属性和方法

如果需要同时检查很多键而不需要多次调用`IsKey`方法，那么`GetPressedKeys`方法很有用。这对于使用组合键的游戏来说很方便。如果您只想检查某个键是否被按下，那么`IsKey`方法就是您想要使用的方法。

和`Keyboard`类一样，`the`鼠标类主要用于获取鼠标的状态。然而，还有另外两种方法`SetCursor`和`SetPosition`，你可能会发现在某些情况下很有用。

您可以调用`SetCursor`方法来使用窗口光标，并将其更改为提供的光标之一，而不是绘制自己的光标:

| **名称** | **描述** |
| --- | --- |
| `Arrow` | 获取默认箭头光标 |
| `Crosshair` | 获取十字准线(“+”)光标 |
| `Hand` | 获取手光标 |
| `Handle` | 不适用的 |
| `IBeam` | 获取当鼠标位于文本编辑区域上时出现的光标 |
| `No` | 获取指向无效内容(通常是十字)的光标 |
| `SizeAll` | 获取指向所有方向的光标 |
| `SizeNESW` | 获取东北/西南(“/”)光标 |
| `SizeNS` | 获取垂直的北/南(“&#124;”)光标 |
| `SizeNWSE` | 获取西北/东南(“\”)光标 |
| `SizeWE` | 获取水平(“-”)光标 |
| `Wait` | 获取应用程序/系统繁忙时出现的等待光标 |
| `WaitArrow` | 获取`Arrow`和`Wait`光标之间的交叉 |

表 8–键盘状态结构属性和方法

您必须通过将`Game.IsMouseVisible` 成员设置为`true`来确保光标可见。

`Crosshair`光标将用作瞄准标线，`Hand`用于指示可以拾取某物等。

`SetPosition`方法为鼠标光标的 x 和 y 位置取两个 int 参数。如果您正在使用窗口光标，并且想要将其锁定在某个区域或点，这可能会很有用。

## "T0" 鼠标状态

`MouseState`结构包含以下属性:

| **名称** | **描述** |
| --- | --- |
| `HorizontalScrollWheelValue` | 返回自游戏开始以来的累计水平滚轮值 |
| `LeftButton` | 不适用的 |
| `MiddleButton` | 不适用的 |
| `Position` | 不适用的 |
| `RightButton` | 不适用的 |
| `ScrollWheelValue` | 返回游戏开始以来累计的滚轮值 |
| `X` | 不适用的 |
| `XButton1` | 不适用的 |
| `XButton2` | 不适用的 |
| `Y` | 不适用的 |

表 9–鼠标状态结构属性

大多数属性是相当明显的。我注意到了两个可能会引起误解的问题。滚轮属性从游戏开始就被跟踪，而不是从最后一帧开始。如果你想要基于框架的值，你必须自己跟踪它们。

有相当多的必要修改我们的游戏，以获得一个不错的输入系统启动和运行。首先，向名为`InputState`的**屏幕管理器**文件夹添加一个类，并向其中添加以下代码:

```cs
  using Microsoft.Xna.Framework;
  using Microsoft.Xna.Framework.Input;

  public class InputState
  {
      public KeyboardState CurrentKeyboardState;
      public GamePadState CurrentGamePadState;

      public KeyboardState LastKeyboardState;
      public GamePadState LastGamePadState;

      public bool MenuUp
      {
          get
          {
              return IsNewKeyPress(Keys.Up)
  ||

  (CurrentGamePadState.DPad.Up == ButtonState.Pressed &&

  LastGamePadState.DPad.Up == ButtonState.Released) ||

  (CurrentGamePadState.ThumbSticks.Left.Y > 0 &&
                      LastGamePadState.ThumbSticks.Left.Y
  <= 0);
          }
      }

      public bool MenuDown
      {
          get
          {
              return IsNewKeyPress(Keys.Down)
  ||

  (CurrentGamePadState.DPad.Down == ButtonState.Pressed &&

  LastGamePadState.DPad.Down == ButtonState.Released) ||

  (CurrentGamePadState.ThumbSticks.Left.Y < 0 &&

  LastGamePadState.ThumbSticks.Left.Y >= 0);
          }
      }

      public bool MenuSelect
      {
          get
          {
              return IsNewKeyPress(Keys.Space)
  ||

  IsNewKeyPress(Keys.Enter) ||

  (CurrentGamePadState.Buttons.A == ButtonState.Pressed &&

  LastGamePadState.Buttons.A == ButtonState.Released) ||

  (CurrentGamePadState.Buttons.Start == ButtonState.Pressed &&

  LastGamePadState.Buttons.Start == ButtonState.Released);
          }
      }

      public bool MenuCancel
      {
          get
          {
              return IsNewKeyPress(Keys.Escape)
  ||

  (CurrentGamePadState.Buttons.B == ButtonState.Pressed &&

  LastGamePadState.Buttons.B == ButtonState.Released) ||

  (CurrentGamePadState.Buttons.Back == ButtonState.Pressed &&

  LastGamePadState.Buttons.Back == ButtonState.Released);
          }
      }

      public bool PauseGame
      {
          get
          {
              return IsNewKeyPress(Keys.Escape)
  ||

  (CurrentGamePadState.Buttons.Back == ButtonState.Pressed &&

  LastGamePadState.Buttons.Back == ButtonState.Released) ||

  (CurrentGamePadState.Buttons.Start == ButtonState.Pressed &&

  LastGamePadState.Buttons.Start == ButtonState.Released);
          }
      }

      public void Update()
      {

  LastKeyboardState = CurrentKeyboardState;
          LastGamePadState
  = CurrentGamePadState;

  CurrentKeyboardState = Keyboard.GetState();

  CurrentGamePadState = GamePad.GetState(PlayerIndex.One);
      }

      public bool IsNewKeyPress(Keys key)
      {
          return (CurrentKeyboardState.IsKeyDown(key) &&

  LastKeyboardState.IsKeyUp(key));
      }
      public bool IsKeyDown(Keys key)
      {
          return (CurrentKeyboardState.IsKeyDown(key));
      }

      public bool IsNewKeyUp(Keys key)
      {
          return (CurrentKeyboardState.IsKeyUp(key) &&

  LastKeyboardState.IsKeyDown(key));
      }
  }

```

代码清单 39–输入状态类

该类保存当前帧和前一帧的键盘和游戏手柄的状态。这是必要的，因为只检查当前帧会给出错误的结果。例如，如果玩家按住控件进行射击，即使只有几分之一秒，如果代码只检查当前的输入状态，游戏也会将其作为多个射击动作进行处理。我们需要检测玩家发起开火动作的第一帧，这只能通过将前一帧的数据与当前帧进行比较来完成。

在通过键盘和游戏手柄的`GetState`方法获得实际的当前帧输入数据之前，`Update`方法将当前帧输入数据复制到前一帧的输入数据中。

`Menu` …和`Pause`成员检查所有可用于导航菜单的各种控件，并返回适当的值，具体取决于是否使用了该操作的控件。

`Is`…成员检查当前键盘状态或当前和以前的键盘状态，如果在该帧中按键被按下、向上或向下，则返回适当的值。

由于每个屏幕都将使用这个类，我们将向每个实例将覆盖的`GameScreen`类添加一个虚拟方法:

```cs
  public virtual void HandleInput(InputState input, GameTime gameTime) { }

```

代码清单 40–游戏屏幕手柄输入法

这个类只用于非游戏性输入。在实际游戏中，我们需要一些更加健壮和灵活的东西来控制我们的角色。

我们的输入系统将使用接口和类来创建一个系统，该系统将特定的控件映射到特定的动作。玩家可以采取七种不同的行动:

*   火
*   移动
*   向后移动
*   前进
*   向左移动
*   向右移动
*   辐状的

界面看起来相当简单，但允许很大的灵活性。在根项目文件夹中创建一个文件调用`IInputSystem`，并向其中添加以下代码:

```cs
  using System.Collections.Generic;

  interface IInputSystem
  {
      List<MappedAction> MappedActions { get; set; }
      void SetActionFunction(string name, ActionDelegate function);
      void Enable();
  }

```

代码清单 41–输入系统接口

`MappedAction`类允许我们将控件与动作相关联。

`SetActionFunction`基本上就是它的名字——它允许我们为一个与用户友好的名字相关联的动作添加一个功能。这个方法的实现将在`InputSystem`类中完成，我们将很快添加实现这个接口的类。

`Enable`方法让我们禁用输入系统，直到我们进入实际游戏。我们在游戏开始时设置输入系统，并允许用户配置动作的控制，但我们不希望系统实际运行到游戏开始，因为我们有一个不同的系统来控制菜单系统。

是时候添加这个接口引用的`MappedAction`类了。将此类文件添加到根文件夹，并用以下代码填充它:

```cs
  class MappedAction
  {
      private string _name;
      private Control _control;
      private ActionType _action;
      private ActionDelegate _function;

      public MappedAction(string
  name, Control control, ActionType action, ActionDelegate function)
      {
          _name = name;
          _control =
  control;
          _action =
  action;
          _function =
  function;
      }

      public string Name
      {
          get { return _name; }
          set { _name = value; }
      }

      public Control ActionControl
      {
          get { return _control; }
          set { _control = value; }
      }

      public ActionType Action
      {
          get { return _action; }
          set { _action = value; }
      }

      public ActionDelegate Function
      {
          get { return (ActionDelegate) _function; }
          set { _function = value; }
      }
  }

```

代码清单 42–映射动作类

`Name`成员允许我们以正确的英语显示用户动作。由于枚举不能在不同的单词之间有空格，并且可能不会按照您想要向用户显示的内容来命名，因此我们有一个成员可以设置为我们想要向用户显示的内容。

`Control`和`ActionType`成员是枚举。我们现在来定义它们。将名为**的输入系统**的文件添加到根文件夹中，并为这两个成员添加枚举:

```cs
  public enum
  ActionType
  {
      Move,
      MoveForward,
      MoveBackward,
      MoveLeft,
      MoveRight,
      Rotate,
      Fire
  }

  public enum
  Control
  {
      AButton,
      BButton,
      XButton,
      YButton,
      StartButton,
      BackButton,
      LeftTrigger,
      RightTrigger,
      LeftShoulder,
      RightShoulder,
      LeftStick,
      RightStick,
      DPadUp,
      DPadDown,
      DPadLeft,
      DPadRight,
      None,
      Back,
      Tab,
      Enter,
      CapsLock,
      Escape,
      Space,
      PageUp,
      PageDown,
      End,
      Home,
      Left,
      Up,
      Right,
      Down,
      Select,
      Print,
      Execute,
      PrintScreen,
      Insert,
      Delete,
      Help,
      D0,
      D1,
      D2,
      D3,
      D4,
      D5,
      D6,
      D7,
      D8,
      D9,
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H,
      I,
      J,
      K,
      L,
      M,
      N,
      O,
      P,
      Q,
      R,
      S,
      T,
      U,
      V,
      W,
      X,
      Y,
      Z,
      LeftWindows,
      RightWindows,
      Apps,
      Sleep,
      NumPad0,
      NumPad1,
      NumPad2,
      NumPad3,
      NumPad4,
      NumPad5,
      NumPad6,
      NumPad7,
      NumPad8,
      NumPad9,
      Multiply,
      Add,
      Separator,
      Subtract,
      Decimal,
      Divide,
      F1,
      F2,
      F3,
      F4,
      F5,
      F6,
      F7,
      F8,
      F9,
      F10,
      F11,
      F12,
      F13,
      F14,
      F15,
      F16,
      F17,
      F18,
      F19,
      F20,
      F21,
      F22,
      F23,
      F24,
      NumLock,
      Scroll,
      LeftShift,
      RightShift,
      LeftControl,
      RightControl,
      LeftAlt,
      RightAlt,
      BrowserBack,
      BrowserForward,
      BrowserRefresh,
      BrowserStop,
      BrowserSearch,
      BrowserFavorites,
      BrowserHome,
      VolumeMute,
      VolumeDown,
      VolumeUp,
      MediaNextTrack,
      MediaPreviousTrack,
      MediaStop,
      MediaPlayPause,
      LaunchMail,
      SelectMedia,
      LaunchApplication1,
      LaunchApplication2,
      OemSemicolon,
      OemPlus,
      OemComma,
      OemMinus,
      OemPeriod,
      OemQuestion,
      OemTilde,
      OemOpenBrackets,
      OemPipe,
      OemCloseBrackets,
      OemQuotes,
      Oem8,
      OemBackslash,
      ProcessKey,
      Attn,
      Crsel,
      Exsel,
      EraseEof,
      Play,
      Zoom,
      Pa1,
      OemClear,
      LeftMouseButton,
      MiddleMouseButton,
      RightMouseButton,
      MouseButton1,
      MouseButton2
  }

```

代码清单 43–输入系统枚举

`Control`枚举拥有所有可能的游戏手柄、键盘和鼠标输入控件。它们中的许多是你永远不会考虑用来控制一个动作的，但是它们包括了你可能想要添加的任何其他功能的未来扩展。

`ActionDelegate`功能定义如下:

```cs
  public delegate void
  ActionDelegate(object value, GameTime gameTime);

```

代码清单 44——action delegate 定义

如果您不熟悉委托，我们在这里使用它们来定义为用户可以让角色执行的每种类型的操作的事件传递的参数。这些事件将在我们现在定义的`InputSystem`类中。将此添加到**输入系统**文件中:

```cs

  class InputSystem : GameComponent, IInputSystem
  {
      public event ActionDelegate Move;
      public event ActionDelegate MoveForward;
      public event ActionDelegate MoveBackward;
      public event ActionDelegate MoveLeft;
      public event ActionDelegate MoveRight;
      public event ActionDelegate Stop;
      public event ActionDelegate Rotate;
      public event ActionDelegate Fire;

      private GamePadState _lastGamePadState;
      private KeyboardState _lastKeyboardState;
      private GamePadState _curGamePadState;
      private KeyboardState _curKeyboardState;
      private MouseState _curMouseState;
      private MouseState _lastMouseState;

      private List<MappedAction> _mappedActions; 

      public List<MappedAction> MappedActions
      {
          get { return _mappedActions; }
          set { _mappedActions = value; }
      }

      public InputSystem(Game
  game)
          : base(game)
      {
          _mappedActions =
  new List<MappedAction>();
      }

      public override void
  Initialize()
      {
      }

      public void Enable()
      {
          this.Enabled = true;
      }

      public void AddAction(string name, Control
  control, ActionType type, ActionDelegate function)
      {
          MappedAction action = new MappedAction(name, control, type, function);

  _mappedActions.Add(action);
      }

      public void SetActionControl(string name, Control
  control)
      {
          foreach (MappedAction action in _mappedActions)
          {
              if (action.Name == name)
              {

  action.ActionControl = control;
                  break;
              }
          }
      }

      public void SetActionFunction(string name, ActionDelegate function)
      {
          if (name == "Stop")
              this.Stop += function;

          foreach (MappedAction action in _mappedActions)
          {
              if (action.Name == name)
              {

  action.Function = function;
                  break;
              }
          }
      } 

      public override void
  Update(GameTime gameTime)
      {
          _curGamePadState
  = GamePad.GetState(PlayerIndex.One);

  _curKeyboardState = Keyboard.GetState();
          _curMouseState =
  Mouse.GetState();

          int dir = -1;
          bool moving = false;

          //we only need to look at the
  controls mapped to actions
              if (Enabled)
              {
                  foreach (MappedAction action in _mappedActions)
                  {
                      switch (action.ActionControl)
                      {
                          case Control.AButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.A, gameTime);

  }

  else

  {

  if (_curGamePadState.Buttons.A == ButtonState.Pressed &&
  _lastGamePadState.Buttons.A == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.BButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.B, gameTime);

  }
                              else

  {

  if (_curGamePadState.Buttons.B == ButtonState.Pressed &&
  _lastGamePadState.Buttons.B == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.XButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.X, gameTime);

  }

  else

  {

  if (_curGamePadState.Buttons.X == ButtonState.Pressed &&
  _lastGamePadState.Buttons.X == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.YButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.Y, gameTime);

  }

  else

  {

     if (_curGamePadState.Buttons.Y == ButtonState.Pressed &&
  _lastGamePadState.Buttons.Y == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.StartButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.Start, gameTime);

   }

  else

  {

  if (_curGamePadState.Buttons.Start == ButtonState.Pressed &&
  _lastGamePadState.Buttons.Start == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.BackButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.Back, gameTime);

  }

  else

  {

  if (_curGamePadState.Buttons.Back == ButtonState.Pressed &&
  _lastGamePadState.Buttons.Back == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.LeftTrigger:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Triggers.Left, gameTime);

  }

  else
                              {

  if (_curGamePadState.Triggers.Left ==
  1.0f && _lastGamePadState.Triggers.Left < 1.0f)

  action.Function(null, gameTime);

  }

  break;

                          case Control.RightTrigger:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Triggers.Right, gameTime);

  }

  else

  {

  if (_curGamePadState.Triggers.Right ==
  1.0f && _lastGamePadState.Triggers.Right < 1.0f)
                                      action.Function(null, gameTime);

  }

  break;

                          case Control.LeftShoulder:

  if (action.Action < ActionType.Fire)
                              {

  action.Function(_curGamePadState.Buttons.LeftShoulder, gameTime);

  }

  else

  {

  if (_curGamePadState.Buttons.LeftShoulder
  == ButtonState.Pressed &&
  _lastGamePadState.Buttons.LeftShoulder == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.RightShoulder:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.Buttons.RightShoulder, gameTime);
                              }

  else

  {

  if
  (_curGamePadState.Buttons.RightShoulder == ButtonState.Pressed && _lastGamePadState.Buttons.RightShoulder == ButtonState.Released)
                                      action.Function(null, gameTime);

  }

  break;

                          case Control.LeftStick:

  if (action.Action < ActionType.Fire)

  {

  //convert to a
  direction

  if (_curGamePadState.ThumbSticks.Left
  != Vector2.Zero)

  {

  float degrees = ((float)(Math.Atan2(_curGamePadState.ThumbSticks.Left.X,
  _curGamePadState.ThumbSticks.Left.Y) * 57.2957795));

  if (degrees < 0)

  {

  if (degrees >= -67)

  dir = (int)Direction.NorthWest;

  else if
  (degrees >= -112)

  dir = (int)Direction.West;

  else if
  (degrees >= -157)

  dir = (int)Direction.SouthWest;

  else

  dir = (int)Direction.South;

  }

  else

  {

  dir = (int)((int)(degrees
  / 45));

  }
                                      action.Function((Direction)dir, gameTime);

  if (action.Action < ActionType.Rotate)

  moving = true;

  }

  else if
  (action.Action < ActionType.Rotate)

  moving = false;

  }

  else

  {

  if (_curGamePadState.ThumbSticks.Left
  != Vector2.Zero &&
  _lastGamePadState.ThumbSticks.Left == Vector2.Zero)

  action.Function(_curGamePadState.ThumbSticks.Left, gameTime);

  }

                              break;

                          case Control.RightStick:

  if (action.Action < ActionType.Fire)

  {

  //convert to a
  direction

  if (_curGamePadState.ThumbSticks.Right
  != Vector2.Zero)

  {

  float degrees = ((float)(Math.Atan2(_curGamePadState.ThumbSticks.Right.X,
  _curGamePadState.ThumbSticks.Right.Y) * 57.2957795));

                                      if (degrees < 0)

  {

  if (degrees >= -67)

  dir = (int)Direction.NorthWest;

          else if
  (degrees >= -112)

  dir = (int)Direction.West;

  else if
  (degrees >= -157)

  dir = (int)Direction.SouthWest;
                                          else

  dir = (int)Direction.South;

  }

  else

  {

           dir = (int)((int)(degrees
  / 45));

  }

  action.Function((Direction)dir, gameTime);

  if (action.Action < ActionType.Rotate)

  moving = true;

  }

  else if
  (action.Action < ActionType.Rotate)

  moving = false;

  }

  else

  {

  if (_curGamePadState.ThumbSticks.Right
  != Vector2.Zero &&
  _lastGamePadState.ThumbSticks.Right == Vector2.Zero)

  action.Function(_curGamePadState.ThumbSticks.Right, gameTime);

  }

  break;

                          case Control.DPadUp:

  if (action.Action < ActionType.Fire)
                              {

  action.Function(_curGamePadState.DPad.Up, gameTime);

  }

  else

  {

  if (_curGamePadState.DPad.Up == ButtonState.Pressed &&
  _lastGamePadState.DPad.Up == ButtonState.Released)

  action.Function(_curGamePadState.DPad.Up, gameTime);

  }

  break;

                          case Control.DPadDown:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.DPad.Down, gameTime);

  }

  else

  {

  if (_curGamePadState.DPad.Down == ButtonState.Pressed &&
  _lastGamePadState.DPad.Down == ButtonState.Released)

  action.Function(_curGamePadState.DPad.Down, gameTime);

  }

  break;

                          case Control.DPadLeft:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.DPad.Left, gameTime);

  }

  else

  {

  if (_curGamePadState.DPad.Left == ButtonState.Pressed &&
  _lastGamePadState.DPad.Left == ButtonState.Released)

  action.Function(_curGamePadState.DPad.Left, gameTime);

  }

  break;

                          case Control.DPadRight:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curGamePadState.DPad.Right, gameTime);

  }

  else

  {

  if (_curGamePadState.DPad.Right == ButtonState.Pressed &&
  _lastGamePadState.DPad.Right == ButtonState.Released)

  action.Function(_curGamePadState.DPad.Right, gameTime);

  }

  break;

                          case Control.Back:
                          case Control.Tab:
                          case Control.Enter:
                          case Control.CapsLock:
                          case Control.Escape:
                          case Control.Space:
                          case Control.PageUp:
                          case Control.PageDown:
                          case Control.End:
                          case Control.Home:
                          case Control.Left:
                          case Control.Up:
                          case Control.Right:
                          case Control.Down:
                          case Control.Select:
                          case Control.Print:
                          case Control.Execute:
                          case Control.PrintScreen:
                          case Control.Insert:
                          case Control.Delete:
                          case Control.Help:
                          case Control.D0:
                          case Control.D1:
                          case Control.D2:
                          case Control.D3:
                          case Control.D4:
                          case Control.D5:
                          case Control.D6:
                          case Control.D7:
                          case Control.D8:
                          case Control.D9:
                          case Control.A:
                          case Control.B:
                          case Control.C:
                          case Control.D:
                          case Control.E:
                          case Control.F:
                          case Control.G:
                          case Control.H:
                          case Control.I:
                          case Control.J:
                          case Control.K:
                          case Control.L:
                          case Control.M:
                          case Control.N:
                          case Control.O:
                          case Control.P:
                          case Control.Q:
                          case Control.R:
                          case Control.S:
                          case Control.T:
                          case Control.U:
                          case Control.V:
                          case Control.W:
                          case Control.X:
                          case Control.Y:
                          case Control.Z:
                          case Control.LeftWindows:
                          case Control.RightWindows:
                          case Control.Apps:
                          case Control.Sleep:
                          case Control.NumPad0:
                          case Control.NumPad1:
                          case Control.NumPad2:
                          case Control.NumPad3:
                          case Control.NumPad4:
                          case Control.NumPad5:
                          case Control.NumPad6:
                          case Control.NumPad7:
                          case Control.NumPad8:
                          case Control.NumPad9:
                          case Control.Multiply:
                          case Control.Add:
                          case Control.Separator:
                          case Control.Subtract:
                          case Control.Decimal:
                          case Control.Divide:
                          case Control.F1:
                          case Control.F2:
                          case Control.F3:
                          case Control.F4:
                          case Control.F5:
                          case Control.F6:
                          case Control.F7:
                          case Control.F8:
                          case Control.F9:
                          case Control.F10:
                          case Control.F11:
                          case Control.F12:
                          case Control.F13:
                          case Control.F14:
                          case Control.F15:
                          case Control.F16:
                          case Control.F17:
                          case Control.F18:
                          case Control.F19:
                          case Control.F20:
                          case Control.F21:
                          case Control.F22:
                          case Control.F23:
                          case Control.F24:
                          case Control.NumLock:
                          case Control.Scroll:
                          case Control.LeftShift:
                          case Control.RightShift:
                          case Control.LeftControl:
                          case Control.RightControl:
                          case Control.LeftAlt:
                          case Control.RightAlt:
                          case Control.BrowserBack:
                          case Control.BrowserForward:
                          case Control.BrowserRefresh:
                          case Control.BrowserStop:
                          case Control.BrowserSearch:
                          case Control.BrowserFavorites:
                          case Control.BrowserHome:
                          case Control.VolumeMute:
                          case Control.VolumeDown:
                          case Control.VolumeUp:
                          case Control.MediaNextTrack:
                          case Control.MediaPreviousTrack:
                          case Control.MediaStop:
                          case Control.MediaPlayPause:
                          case Control.LaunchMail:
                          case Control.SelectMedia:
                          case Control.LaunchApplication1:
                          case Control.LaunchApplication2:
                          case Control.OemSemicolon:
                          case Control.OemPlus:
                          case Control.OemComma:
                          case Control.OemMinus:
                          case Control.OemPeriod:
                          case Control.OemQuestion:
                          case Control.OemTilde:
                          case Control.OemOpenBrackets:
                          case Control.OemPipe:
                          case Control.OemCloseBrackets:
                          case Control.OemQuotes:
                          case Control.Oem8:
                          case Control.OemBackslash:
                          case Control.ProcessKey:
                          case Control.Attn:
                          case Control.Crsel:
                          case Control.Exsel:
                          case Control.EraseEof:
                          case Control.Play:
                          case Control.Zoom:
                          case Control.Pa1:
                          case Control.OemClear:

  //we can use one case
  here
                              if (action.Action < ActionType.Fire)

  {

  action.Function(_curKeyboardState.IsKeyDown((Keys)(action.ActionControl - (action.ActionControl - 1))),
  gameTime);

  }

  else

  {

  if (_curKeyboardState.IsKeyDown((Keys)(action.ActionControl - (action.ActionControl - 1)))
  && _lastKeyboardState.IsKeyUp((Keys)(action.ActionControl
  - (action.ActionControl - 1))))

  action.Function(null, gameTime);

  }

  break;

                          case Control.LeftMouseButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curMouseState.LeftButton, gameTime);

  }

  else

  {

  if (_curMouseState.LeftButton == ButtonState.Pressed &&
  _lastMouseState.LeftButton == ButtonState.Released)

  action.Function(null, gameTime);
                              }

  break;

                          case Control.MiddleMouseButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curMouseState.MiddleButton, gameTime);

  }

  else

  {

  if (_curMouseState.MiddleButton == ButtonState.Pressed &&
  _lastMouseState.MiddleButton == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.RightMouseButton:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curMouseState.RightButton, gameTime);

  }

  else
                              {

  if (_curMouseState.RightButton == ButtonState.Pressed &&
  _lastMouseState.RightButton == ButtonState.Released)

  action.Function(null, gameTime);
                              }

  break;

                          case Control.MouseButton1:

  if (action.Action < ActionType.Fire)

  {

  action.Function(_curMouseState.XButton1, gameTime);

  }

  else

  {

  if (_curMouseState.XButton1 == ButtonState.Pressed &&
  _lastMouseState.XButton1 == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;

                          case Control.MouseButton2:

  if (action.Action < ActionType.Fire)
                              {

  action.Function(_curMouseState.XButton2, gameTime);

  }

  else

  {

  if (_curMouseState.XButton2 == ButtonState.Pressed &&
  _lastMouseState.XButton2 == ButtonState.Released)

  action.Function(null, gameTime);

  }

  break;
                      }
                  }

                  if (!moving)
                  {

  Stop(null, gameTime);
                  }
              }

  _lastGamePadState = _curGamePadState;

  _lastKeyboardState = _curKeyboardState;

  _lastMouseState=_curMouseState;

      }
  }

```

代码清单 45–输入系统类

这里发生了很多事情，让我们仔细看看。

我们首先看到的是`ActionDelegate`委托的实现。我们有八种类型的行动需要我们去做。请注意`Stop`有一个`ActionDelegate`。如果玩家没有做我们之前提到的与移动相关的动作，我们会阻止角色移动。

接下来的成员是我们将要处理的输入设备的当前和以前的状态。

在这之后，我们有了我们的接口的实现。我们还提供了多种允许修改映射动作的方法。

如您所料，`Update`方法是类中最大的代码块。在获得输入设备的当前状态后，如果输入系统被启用，我们会检查所有映射的动作，检查当前输入，看条件是否匹配，以触发与该动作相关联的功能。

如果在评估所有动作后，确定角色没有移动，则调用`Stop`动作功能。然后，我们将当前输入状态设置为最后输入状态。

`InputSystem`实例在`Game`类中创建:

```cs
  InputSystem input;

  protected override void Initialize()
  {
  . . . 

      input = new InputSystem(this);

      //we don't want to use this until we
  play the game or configure the controls
      input.Enabled = false;

      input.AddAction("Move", Control.LeftStick,
  ActionType.Move, null);
      input.AddAction("Move Foward", Control.DPadUp,
  ActionType.MoveForward, null);
      input.AddAction("Move Backward", Control.DPadDown,
  ActionType.MoveBackward, null);
      input.AddAction("Move Left", Control.DPadLeft,
  ActionType.MoveLeft, null);
      input.AddAction("Move Right", Control.DPadRight,
  ActionType.MoveRight, null);
      input.AddAction("Fire", Control.RightTrigger, ActionType.Fire,
  null);
      input.AddAction("Rotate", Control.RightStick,
  ActionType.Rotate, null);

  Components.Add(input);

      this.Services.AddService(typeof(IInputSystem), input);
  }

```

代码清单 46–输入系统激活

只有当玩家已经开始实际游戏时，输入系统才被启用。这发生在`GameplayScreen`类的`Initialize`方法中:

```cs
  IInputSystem input = ((IInputSystem)ScreenManager.Game.Services.GetService(typeof(IInputSystem)));

  input.SetActionFunction("Move", Move);
  input.SetActionFunction("Move Foward", MoveForward);
  input.SetActionFunction("Move Backward", MoveBackward);
  input.SetActionFunction("Move Left", MoveLeft);
  input.SetActionFunction("Move Right", MoveRight);
  input.SetActionFunction("Fire", Fire);
  input.SetActionFunction("Rotate", Rotate);
  input.SetActionFunction("Stop", Stop);

  input.Enable();

```

代码清单 47–输入系统激活

`SetActionFunction`方法调用的`ActionDelegate`参数是`GameplayScreen`类中的方法:

```cs
  private void
  Move(object value, GameTime gameTime)
  {

  _entityManager.MovePlayer((Direction)value);
  }

  private void
  MoveForward(object value, GameTime gameTime)
  {
      if (value != null)
      {
          if ((ButtonState)value == ButtonState.Pressed)
          {

  _entityManager.MovePlayer(_entityManager.GetPlayerDirection());
          }
      }
  }

  private void
  MoveBackward(object value, GameTime gameTime)
  {
      if (value != null)
      {
          if ((ButtonState)value == ButtonState.Pressed)
          {
              Direction dir =
  _entityManager.GetPlayerDirection();

              if (dir < Direction.South)
                  dir +=
  4;
              else
                  dir = (Direction)((int)Direction.NorthWest - (int)dir);

  _entityManager.MovePlayer(dir);
          }
      }
  }

  private void
  MoveLeft(object value, GameTime gameTime)
  {
      if (value != null)
      {
          if ((ButtonState)value == ButtonState.Pressed)
          {
              Direction dir =
  _entityManager.GetPlayerDirection();

              if (dir < Direction.East)
                  dir +=
  6;
              else
                  dir = (Direction)((int)Direction.NorthWest - (int)dir);

  _entityManager.MovePlayer(dir);
          }
      }
  }

  private void
  MoveRight(object value, GameTime gameTime)
  {
      if (value != null)
      {
          if ((ButtonState)value == ButtonState.Pressed)
          {
              Direction dir = _entityManager.GetPlayerDirection();

              if (dir < Direction.West)
                  dir +=
  2;
              else
                  dir = (Direction)((int)Direction.NorthWest - (int)dir);

  _entityManager.MovePlayer(dir);
          }
      }
  }

  private void
  Rotate(object value, GameTime gameTime)
  {
      if (value != null)
      {

  _entityManager.SetPlayerDirection((Direction)value);
      }
  }

  private void
  Stop(object value, GameTime gameTime)
  {

  _entityManager.StopPlayer();
  }

  private void
  Fire(object value, GameTime gameTime)
  {

  _entityManager.PlayerFire();
  }

```

代码清单 48–输入系统操作方法

`EntityManager`类负责解析玩家采取的所有动作。我们已经开始了一点`EntityManager`，我们将继续用这里调用的方法来充实它:

```cs
  public void
  SetPlayerDirection(Direction dir)
  {
      if (_entities.Count > 0)
      {
          _entities[0].MoveDirection
  = dir;
      }
  }

  public void
  StopPlayer()
  {
      if (_entities.Count > 0)
      {

  _entities[0].Speed = 0.0f;
      }
  }

  public Direction GetPlayerDirection()
  {
      if (_entities.Count > 0)
      {
          return _entities[0].MoveDirection;
      }
      else
          return Direction.North;
  }

  public void
  MovePlayer(Direction dir)
  {
      if (_entities.Count > 0)
      {

  _entities[0].MoveDirection = dir;

  _entities[0].Speed = 3.0f;
      }
  }

  public void
  PlayerFire()
  {
      if (_entities.Count > 0)
      {

      }
  }

```

代码清单 49–实体管理员操作方法

这些方法包括一个健全性检查，以确保我们没有试图设置空对象的属性。这种情况永远不会发生，但这种验证是一种很好的做法。

如果我们移动角色，我们确保他的速度被设置为默认值。你可以在这里使用一个常量，其他常量可以用于一个速度比正常速度快或慢的角色。如果你在游戏中加入能量，这是可以做到的。

注意`PlayerFire`方法中的空`if`语句。我们将在下一章实现音频。

我们需要实现的最后一块是`InputState`实例。这进入`ScreenManager`类，在那里它也被更新并传递到屏幕:

```cs
  InputState _input = new InputState();

  public override void Update(GameTime gameTime)
  {
      // Read the keyboard and gamepad.
      _input.Update();

  . . .

      while (_screensToUpdate.Count > 0)
      {
          // Pop the topmost screen off the waiting
  list.
          GameScreen screen =
  _screensToUpdate[_screensToUpdate.Count - 1];

  _screensToUpdate.RemoveAt(_screensToUpdate.Count - 1);

          // Update the screen.

  screen.Update(gameTime, otherScreenHasFocus, coveredByOtherScreen);

          if (screen.ScreenState == ScreenState.TransitionOn ||

  screen.ScreenState == ScreenState.Active)
          {
              // If this is the first active
  screen we came across,
              // give it a chance to handle input.
              if (!otherScreenHasFocus)
              {

  screen.HandleInput(_input, gameTime);

  otherScreenHasFocus = true;
              }

              // If this is an active non-popup,
  inform any subsequent
              // screens that they are covered by
  it.
              if (!screen.IsPopup)

  coveredByOtherScreen = true;
          }
      }

      if (_traceEnabled)
          TraceScreens();
  }

```

代码清单 50–屏幕管理器更新更新方法

我们需要给几个类添加输入处理，从`HighScoreScreen`类开始:

```cs
  public override void HandleInput(InputState input, GameTime gameTime)
  {
      if ((input.CurrentGamePadState.Buttons.B ==
  Microsoft.Xna.Framework.Input.ButtonState.Pressed && input.LastGamePadState.Buttons.B ==
  Microsoft.Xna.Framework.Input.ButtonState.Released) ||

  (input.CurrentKeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.Escape) &&
  input.LastKeyboardState.IsKeyUp(Microsoft.Xna.Framework.Input.Keys.Escape)))
          this.ExitScreen();

      base.HandleInput(input, gameTime);
  }

```

代码清单 51–高速核心屏幕手柄输入法

`MessageBoxScreen`类:

```cs
  public override void HandleInput(InputState input, GameTime gameTime)
  {
      if (input.MenuSelect)
      {
          // Raise the accepted event, then
  exit the message box.
          if (Accepted != null)
              Accepted(this, EventArgs.Empty);

          ExitScreen();
      }
      else if (input.MenuCancel)
      {
          // Raise the cancelled event, then
  exit the message box.
          if (Cancelled != null)
              Cancelled(this, EventArgs.Empty);

          ExitScreen();
      }
  }

```

代码清单 52–消息框屏幕处理输入方法

`GameplayScreen`类:

```cs
  public override void HandleInput(InputState input, GameTime gameTime)
  {
      if (input == null)
          throw new ArgumentNullException("input");

      if (input.PauseGame)
      {

  ScreenManager.AddScreen(new PauseMenuScreen());
      }
  }

```

代码清单 53–游戏屏幕手柄输入法

`MenuScreen`类:

```cs
  public override void HandleInput(InputState input, GameTime gameTime)
  {
      // Move to the previous menu entry?
      if (input.MenuUp)
      {

  _selectedEntry--;

          if (_selectedEntry < 0)

  _selectedEntry = _menuEntries.Count - 1;
      }

      // Move to the next menu entry?
      if (input.MenuDown)
      {

  _selectedEntry++;

          if (_selectedEntry >= _menuEntries.Count)

  _selectedEntry = 0;
      }

      // Accept or cancel the menu?
      if (input.MenuSelect)
      {
          OnSelectEntry(_selectedEntry);

      }
      else if (input.MenuCancel)
      {
          OnCancel();
      }

      if (input.IsNewKeyPress(Keys.Left))
          OnNewArrowDown(Keys.Left, _selectedEntry);
      else if (input.IsKeyDown(Keys.Left))
          OnArrowDown(Keys.Left, _selectedEntry, gameTime);

      if (input.IsNewKeyUp(Keys.Left))
          OnArrowUp(Keys.Left, _selectedEntry);

      if (input.IsNewKeyPress(Keys.Right))
          OnNewArrowDown(Keys.Right, _selectedEntry);
      else if (input.IsKeyDown(Keys.Right))
          OnArrowDown(Keys.Right,_selectedEntry, gameTime);

      if (input.IsNewKeyUp(Keys.Right))
          OnArrowUp(Keys.Right, _selectedEntry);

  }

```

代码清单 54–菜单屏幕手柄输入法

现在我们有了一个输入系统，我们需要给玩家一个方法来改变哪些控件映射到我们定义的动作。我们将添加一个新的屏幕来实现这一点。在**屏幕**文件夹中创建新类，并添加以下内容:

```cs
  class ControlsScreen : MenuScreen
  {
      private string[] _items;
      private int[] _selectedIndices;

      private bool _leftArrowDown = false;
      private bool _rightArrowDown = false;

      private float _leftArrowDownTime = 0.0f;
      private float _rightArrowDownTime = 0.0f;

      private List<MappedAction> _actions;

      public ControlsScreen()
      {
      }

      public override void
  Initialize()
      {
          base.Initialize();

          //get the current configuration and
  load the menu
          _actions = ((IInputSystem)ScreenManager.Game.Services.GetService(typeof(IInputSystem))).MappedActions;

          _selectedIndices
  = new int[_actions.Count];

          int count = 0;

          foreach (MappedAction action in _actions)
          {

  _menuEntries.Add(action.Name + ": ");

  _selectedIndices[count] = (int)action.ActionControl;
              count++;
          }

  _menuEntries.Add("Back");

          //populate items array with all
  available controls
          _items = new string[System.Enum.GetNames(typeof(Control)).Length];

          count = 0;

          //Loop through Keys enum
          foreach (int value in System.Enum.GetValues(typeof(Control)))
          {

  _items[count] = System.Enum.GetName(typeof(Control), value);
              count++;
          }

      }

      public override void
  Update(GameTime gameTime, bool otherScreenHasFocus,

  bool coveredByOtherScreen)
      {
          base.Update(gameTime, otherScreenHasFocus,
  coveredByOtherScreen);

          int count = 0;
          string entry;

          for (count = 0; count < _actions.Count;count++ )
          {
              entry =
  _actions[count].Name + ":
  " +
  _items[_selectedIndices[count]];

  _menuEntries[count] = entry;
          }
      }

      protected override void OnSelectEntry(int entryIndex)
      {
          //increment and check item
          if (entryIndex == 7)
          {
              // Go back to the main menu.

  ExitScreen();
          }
      }

      protected override void OnArrowUp(Keys arrow, int
  entryIndex)
      {
          int index = _selectedIndices[entryIndex]++;

          switch (arrow)
          {
              case Keys.Left:

                  index--;

                  if (index < 0)

  index = _items.Length - 1;

                  break;

              case Keys.Right:
                  index++;

                  if (index > _items.Length - 1)

  index = 0;

                  break;
          }

  _selectedIndices[entryIndex] = index;

      }

      protected override void OnArrowDown(Keys arrow, int
  entryIndex, GameTime gameTime)
      {
          int index = _selectedIndices[entryIndex]++;

          switch (arrow)
          {

              case Keys.Left:

                  if (_leftArrowDown)
                  {

  _leftArrowDownTime += gameTime.ElapsedGameTime.Milliseconds;

                      if (_leftArrowDownTime > 250.0f)
                      {

  index--;

  _leftArrowDownTime = 0.0f;
                      }
                  }
                  else
                  {

  _leftArrowDown = true;

  _leftArrowDownTime = 0.0f;
                  }

                  break;

              case Keys.Right:

                  if (_rightArrowDown)
                  {

  _rightArrowDownTime += gameTime.ElapsedGameTime.Milliseconds;

                      if (_rightArrowDownTime > 250.0f)
                      {

  index++;
                          _rightArrowDownTime
  = 0.0f;
                      }
                  }
                  else
                  {

  _rightArrowDown = true;

  _rightArrowDownTime = 0.0f;
                  }

                  break;

          }

          if (index < 0)
              index =
  _items.Length - 1;
          else if (index == _items.Length)
              index=0;

  _selectedIndices[entryIndex] = index;

      }

      protected override void OnCancel()
      {
          ExitScreen();
      }

      public override void
  ExitScreen()
      {
          //save the controls configuration
          MappedAction action;

          for (int count = 0; count <
  _actions.Count; count++)
          {
              action =
  _actions[count];
              action.ActionControl
  = (Control)_selectedIndices[count];
          }
          ((IInputSystem)ScreenManager.Game.Services.GetService(typeof(IInputSystem))).MappedActions = _actions;

          base.ExitScreen();
      }
  }

```

代码清单 55–控件屏幕类

我们现在有办法控制自己的性格。我们将添加的最后一个系统是音频来处理声音和音乐。