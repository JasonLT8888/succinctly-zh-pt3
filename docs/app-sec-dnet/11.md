# 第十一章网络安全

## ASP.NET 安全

网络应用的安全妥协越来越多[越来越多](http://en.wikipedia.org/wiki/2012_Yahoo!_Voices_hack) [无处不在](http://en.wikipedia.org/wiki/EHarmony#Password_hacked_-_security_breach) [这些](http://news.cnet.com/8301-1009_3-57449037-83/last.fm-warns-users-of-password-leak/) [天](http://arstechnica.com/security/2013/02/twitter-detects-and-shuts-down-password-data-hack-in-progress/)。Web 应用程序提供了一个易于访问的战场，可以将各种安全原语组合成更复杂的安全协议，并通过 web 支持的广泛暴露来测试这些协议的运行情况。如果不是因为一件小事，这就太好了:安全属性[不能以功能方式进行测试](http://www.schneier.com/essay-018.html)(例如，“我们包括安全特性了吗？什么事？勾号！部署到生产！”).最终通常会受到考验的是不安全性，此时已经太晚了(即生产环境受到损害)。

那个。NET web 开发工具的首选是 ASP.NET，这是一个代表众多框架的统称，如 [Web Forms](http://www.asp.net/web-forms) 、 [AJAX](https://en.wikipedia.org/wiki/ASP.NET_AJAX) 、 [Web Pages](http://www.asp.net/web-pages) 、 [MVC](https://en.wikipedia.org/wiki/ASP.NET_MVC_Framework) 、 [Web API](http://www.asp.net/web-api) 、[signor](https://en.wikipedia.org/wiki/SignalR)、 [WCF](http://msdn.microsoft.com/en-us/library/dd456779.aspx) 和 SOAP Web Services ( [ASMX](http://msdn.microsoft.com/en-us/library/ms972326.aspx) )，每一个都在经历自己的演进和成熟周期。在 ASP.NET 的技术组合中有大量的复杂性，复杂性是安全的永恒克星。

微软通过为常见的 web 应用相关需求(如会话管理、用户身份验证(身份管理)、用户授权和凭据存储)提供“即用型”安全组件，努力解决这一复杂性，并取得了不同程度的成功。这些 ASP。NET 提供的安全组件已经过时，因为它们是为 ASP.NET 1.x(2002–2003)或 ASP.NET 2.0(2005)设计的。然而，网络已经向前发展了。现代网络中存在实际上可以利用的漏洞，这些漏洞是善意的 ASP。NET 提供的安全组件从来没有被设计来解决或解决不足。通往失败之坑的道路是由善意铺成的。微软已经让这些提供的安全组件尽可能容易使用(其中一些是默认启用的)，开发人员通过使用它们很容易获得即时的功能满足，但这也是这些组件变得危险的原因。

微软在 ASP.NET 4.0 和 ASP.NET 4.5 上做出了值得称赞的努力，以改进这些广泛使用的安全组件，并在不损害向后兼容性的情况下纳入额外的保护措施(用户基础庞大)。然而，我们觉得许多 ASP。NET 提供的安全组件已经过了它们的到期日，应该用新的方法来代替，这些方法实际上是为现代 web 的威胁和漏洞而设计的。另一方面，我们希望能够重用尽可能多的现有的经过试验和测试的安全功能，因此将只考虑作为最后手段的定制实现。

微软充分意识到有必要使 speed 现代化，并使其跟上现代网络的发展。ASP.NET 5 是对 ASP.NET 框架的重大重新设计，旨在将内部架构从所有阻碍 ASP.NET 发展的“遗产”中解放出来。这一雄心勃勃的努力显然足够激进，足以杀死“T1”ASP。NET 5”，而是将项目重新命名为“ASP。NET 核心”。虽然 ASP.NET 4 . x“王者”正式不再是王者，而且新的王者还不成熟(ASP.NET Core 2.0 仍然缺少至关重要的加密功能)，但仍会有无数的 ASP.NET 4 . x(和 2.x)业务线应用。这些“遗留”应用程序将伴随我们很长一段时间，理解并正确应用它们背后的安全概念非常重要。

## 会话状态

ASP.NET[**会话状态**](https://msdn.microsoft.com/en-us/library/ms178581(v=vs.100).aspx) 组件支持任何可序列化的特定于网络会话的数据的服务器端存储，并且根据 MSDN 的规定，默认情况下为所有 ASP.NET 应用程序启用。客户端通过称为[会话标识符](https://msdn.microsoft.com/en-us/library/system.web.sessionstate.httpsessionstate.sessionid(v=vs.100).aspx)的唯一会话状态标识符来跟踪相关联的服务器端会话状态。SessionID 应该是 Base32 编码、不区分大小写、CSP-RNG 生成的 120 位值(更多信息请参见“ [Base32](05.html#_Base32) ”部分)。

2008 年 12 月(ASP.NET 2.0 发布三年后)，一位研究 SessionID 声称的 120 位熵的安全研究员就此写了一篇[论文](http://www.sentinelchicken.com/research/aspdotnet_sessionid/)。该论文表明，内部算法确实产生了 120 位的熵，但是 Base32 编码实现有一个缺陷，在最坏的情况下，将编码熵从 120 位减少到 96 位，预期的平均熵实际上徘徊在 108 位左右。因此，实际会话密钥空间比声称的小 2 <sup>(120-108)</sup> = 4096 倍。缩减后的密钥空间仍然足够大，任何实际利用都无法触及，但这表明微软也有实施错误。错误在于随机整数的右移位，没有意识到对于负整数，从左传入的位将是 1 而不是 0。

这个缺陷和安全文件都没有被微软公开承认(至少我们在网上找不到它的公开记录)。最新的。NET 在 2008 年是。NET 3.5，它运行在 2.0 运行时上。。NET 4.0 于 2010 年 4 月发布，它引入了新的 4.0 运行时。。NET [广汽](http://en.wikipedia.org/wiki/Global_Assembly_Cache)现在有两个`System.Web.dll`组件在里面:2.0 版和 4.0 版。以下是`Encode()`方法的 2.0 版和 4.0 版算法:

代码清单 18

```cs
  //
  System.Web.SessionState.SessionId class in System.Web.dll version 2.0
  private
  static string Encode(byte[] buffer) {
   char[]
  array = new char[24]; int num = 0;
     for (int
  i = 0; i < 15; i += 5) {
      int num2
  = (int)buffer[i] | (int)buffer[i + 1] << 8 |

  (int)buffer[i + 2] << 16 | (int)buffer[i + 3] << 24;
      int num3
  = num2 & 31;

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 5 & 31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 10 &
  31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 15 &
  31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 20 &
  31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 25 &
  31);

  array[num++] = SessionId.s_encoding[num3];
      num2 =
  (num2 >> 30 | (int)buffer[i + 4] << 2);
      num3 = (num2
  & 31);

  array[num++] = SessionId.s_encoding[num3];
      num3 =
  (num2 >> 5 & 31);

  array[num++] = SessionId.s_encoding[num3];
     }
    return new string(array);
  }

```

代码清单 19

```cs
  //
  System.Web.SessionState.SessionId class in System.Web.dll version 4.0
  private
  static string Encode(byte[] buffer) {
   char[]
  array = new char[24]; int num = 0;
     for (int
  i = 0; i < 15; i += 5) {
      int num2
  = (int)buffer[i] | (int)buffer[i + 1] << 8 |

  (int)buffer[i + 2] << 16 | (int)buffer[i + 3] << 24;
      int num3
  = num2 & 31;

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 5 & 31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 10 &
  31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 15 &
  31);
      array[num++]
  = SessionId.s_encoding[num3]; num3 = (num2 >> 20 & 31);

  array[num++] = SessionId.s_encoding[num3]; num3 = (num2 >> 25 &
  31);

  array[num++] = SessionId.s_encoding[num3];
      num2 =
  (num2 >> 30 & 3 |
  (int)buffer[i + 4] << 2);
      num3 =
  (num2 & 31);

  array[num++] = SessionId.s_encoding[num3];
      num3 =
  (num2 >> 5 & 31);

  array[num++] = SessionId.s_encoding[num3];
     }
    return new string(array);
  }

```

我们强调了微软在 4.0 中的修复。错误的代码行应该使用剩余的 2 个随机位(“> > 30”部分)并将它们与中间结果进行“或”。开发人员假设从左边传入的 30 位是零，但是`num2`是一个`int`，可以是负数。“& 3”修复将这些传入的 30 位清零，而不考虑它们的值。此 SessionID 已修复。据我们所知，NET 4.0 也没有被微软公开提及。一个简单的方法是观察 SessionID 的最后几个字符(基于 2.0 的 session id 通常以“45”或“55”结尾)，来告诉您使用 session id 的 ASP.NET 应用程序仍然在 2.0 运行时运行。MSDN[记录了](https://msdn.microsoft.com/en-us/library/xt18et0d.aspx)右移操作员的正确行为。

会话标识符通过 cookie(默认行为)或作为网址的一部分发送到客户端，所有讨厌的网址重写都由 ASP.NET 处理。默认的基于 cookie 的模式会创建一个 cookie，标记为 [`HttpOnly`](https://www.owasp.org/index.php/HttpOnly) (好)，而不是 [`Secure`](http://msdn.microsoft.com/en-us/library/system.net.cookie.secure.aspx) (不好)。有一个[设置](http://msdn.microsoft.com/en-us/library/ms228262(v=vs.80).aspx)来启用安全会话 cookies，但默认情况下没有打开。您可能仍然会感到放心，因为您的 ASP.NET 应用程序对所有敏感表单和页面都使用了 [TLS](http://en.wikipedia.org/wiki/Transport_Layer_Security) 。SessionID 的另一个方面是，如果客户端无法向服务器端提供匹配的 SessionID 值(要么根本没有提供 SessionID，要么提供的 SessionID 不匹配)，ASP.NET 总是会生成一个全新的服务器端会话状态，并将其 SessionID 作为 cookie 发送给客户端，这将覆盖任何预先存在的客户端 SessionID cookie。

更糟糕的是，如果客户端提供的 SessionID 有效，但与过期或放弃的服务器端会话状态匹配，新生成的服务器端状态将重用相同的客户端提供的 SessionID(同样，有一个[设置](http://msdn.microsoft.com/en-us/library/h6bb9cz9(v=vs.100).aspx)停止重用，但默认情况下不打开)。这种会话 ID 重用有效地使服务器端能够切换到不同的会话状态，而客户端却不知道，因为客户端一直使用相同的会话 ID 值。更糟糕的是，会话状态设计将毫无疑问地接受任何客户端提供的 SessionID 字符串，只要它具有有效的 SessionID 编码。实际上，客户端可以决定并修复自己的 SessionID 的确切值。许多自动漏洞测试扫描都被 ASP.NET session id cookie 处理绊倒，因为它没有通过[会话固定](http://en.wikipedia.org/wiki/Session_fixation)测试。然而，会话固定攻击使用“会话”的不同含义。ASP.NET 会话状态是一个未经身份验证的会话，而会话固定攻击的重点是经过身份验证的会话。

想象以下场景:

*您的银行为所有 ASP.NET 表单和页面运行 TLS，并使用基于 cookie 的会话状态。你觉得做网上银行相当安全。你的银行网站上成千上万个网址中的一个(比如一个静态的 CSS 文件)恰好是 HTTP 而不是 HTTPS。如果 HTTP 资源没有预先加载，而是在点击或新的浏览器窗口中加载，您甚至可能不会收到“混合内容”浏览器警告。会话 ID cookie 不安全地与该 HTTP 请求一起传播。由于你在当地咖啡店通过无线网络银行，你的银行账户在你不知情的情况下刚刚被**劫持。*

防止这种情况的一个简单方法可能是在网络服务器级别实施顶级域名系统，没有例外。然而，大多数网站希望通过 HTTP(至少是主页)访问，然后重定向到安全的 HTTPS 网站。在这种情况下，正确实施具有会话状态的 TLS 的唯一方法是将受 TLS 保护的应用程序放在单独的子域(如 secure.myapp.com)上，并将 SessionID cookies 限制在该子域内。然而，许多 web 应用程序不希望用单独的安全子域给用户带来不便。

问题的根源在于，会话状态从未被设计用于身份验证，但它非常常用于实现 ASP.NET 身份验证。开发人员的无知、糟糕的文档以及容易被误用都是造成这种危险滥用的原因。

| ![](img/tip.png) | 提示:ASP.NET 会话状态不应用于身份验证。 |

**会话状态应该用于什么？我们不确定。有人建议将其用于粘性“非敏感”数据，如用户的颜色偏好。这对我们来说毫无意义，因为“敏感”的部分不是你是否更喜欢“蓝色”而不是“绿色”，而是你对所有权的隐含期望，以及你隐含的假设，即没有人应该能够劫持这一选择。利害攸关的是对客户机-服务器交互神圣性的信任，而不仅仅是数据本身。网络会话中没有所谓的“非敏感”数据——客户端和服务器端之间交换的每一位数据都必须是机密和真实的。**

 **微软提供以下关于会话状态的[指导:*“会话状态功能默认启用。虽然默认配置设置设置为最安全的值，但如果您的应用程序不需要会话状态，则应禁用它。”*](https://msdn.microsoft.com/en-us/library/ms178201(v=vs.100).aspx)

我们只能在此基础上进一步建议您立即禁用会话状态，因为这样您就可以知道或发现您的应用程序不需要会话状态。让应用程序中的会话状态保持启用状态——即使您相当确定今天没有人在使用它——是自找麻烦。如果你让它保持启用状态，有人可能会滥用它。

只是为了再踢一次死马，使用会话状态不应该感到安全——即使你是 100%的 HTTPS，HTTP 甚至不在你的词汇表中。有效的用户-A 仍然可以设置自己的会话状态值，然后修复用户-B 的会话以使用相同的有效用户-A 会话，从而导致用户-B 在甚至不知道 HTTPS 与否的情况下使用用户-A 的会话。如果您试图通过让用户 B 明白他们实际上正在使用用户 A 的会话来修复它，那么您就是在使用会话状态进行身份验证。

您可以从微软的建议中获得另一点智慧:如果默认会话状态已经处于其“最安全”的配置，这对于其他会话状态模式(如无 cookieless 会话)的安全性意味着什么？我们把这个留给读者做练习。

可用性在技术上也是一个安全问题，会话状态也有问题。默认情况下，会话状态处理程序是阻塞的，因为它们需要对会话状态存储进行读写访问，这是一个互斥的操作，需要锁定。有一种[方式](http://msdn.microsoft.com/en-us/library/system.web.sessionstate.sessionstatebehavior.aspx)将 ASP.NET 处理程序配置为只需要读访问，这使得它们不阻塞和并发(以可写性为代价)，但这不是默认方式。看到一个 ASP.NET 应用程序有多个支持 AJAX 的独立网页组件一个接一个地串行加载并不罕见，尽管它们显然是被设计成并发加载的。在某些情况下，最后一个加载请求会在这个人工会话状态处理程序队列中等待时简单地 HTTP 超时。

如果您需要维护特定于用户的服务器端状态，请使用[内存缓存](https://msdn.microsoft.com/en-us/library/system.runtime.caching.memorycache.aspx)(单服务器、非持久)、分布式缓存(如 [Redis](https://azure.microsoft.com/en-us/services/cache/) )，或者简单地使用简单的可选缓存层来利用您的主数据库。如果您使用云托管，还有许多快速键值存储(这就是会话状态)。你也可以考虑在客户端存储状态，不管是否加密，在 cookies 中或者使用[网络存储](https://en.wikipedia.org/wiki/Web_storage)。

我们确实生活在现实世界中，充满了需要支持和维护的传统业务线 ASP.NET 应用程序。但是，我们相信，如果您对新 ASP.NET 解决方案的设计有任何权力，您会明智地使用它。

## CSRF

**跨站点请求伪造(**[**【CSRF】**](https://en.wikipedia.org/wiki/Cross-site_request_forgery)**)**攻击在[OWASP](https://www.owasp.org/index.php/Top_10_2013-A8-Cross-Site_Request_Forgery_%28CSRF%29)*2010 年和 2013 年“十大最关键 Web 应用安全风险”*列表中分别排在第 5 位和第 8 位。大多数开发框架，包括。NET，实现遵循 OWASP 建议的 CSRF 防御(或者，OWASP CSRF 防御建议遵循大多数开发框架目前所做的)。

OWASP 表示如下:

*   防止 CSRF 通常需要在每个 HTTP 请求中包含一个不可预测的令牌。这样的令牌在每个用户会话中至少应该是唯一的。
*   首选选项是在隐藏字段中包含唯一令牌。这将导致该值在 HTTP 请求的正文中发送，从而避免其包含在可能暴露的 URL 中。

你看到这两种说法之间的根本脱节了吗？第一种说法没有错——它清楚地阐明了一个有效的 HTTP 级别的 CSRF 预防解决方案。然而，第二种说法突然谈到了“隐藏字段”中的标记——一个 HTML 特性。HTML 突然从何而来？

[OSI](https://en.wikipedia.org/wiki/OSI_model) 模型在概念上代表了使网络工作的许多协议层。在该模型中，您会发现 HTTP 是最顶层的“应用层”协议。HTML 不在该模型中，因为它是一种“有效载荷”协议，就像 JPEG、PNG、XML、JSON、CSS 或任何其他可以通过 HTTP 传输的有效载荷一样。

在 HTML 中实现 CSRF 防御就像在海洋中央建造一座大坝来堵住漏洞。CSRF 是困惑的副手问题的变体，这个问题有两个组成部分:基于信任的权威，以及导致滥用这种权威的混乱。web 上的权限通常由客户端对服务器的身份验证来驱动，这允许服务器从客户端的身份推断权限。ASP.NET[支持](http://msdn.microsoft.com/en-us/library/eeyk640h%28v=vs.100%29.aspx)两种主要身份验证模式:Windows 身份验证和表单身份验证。我们还没有讨论其中的任何一个，但是只要知道这两种身份验证模式都在 HTTP 级别建立身份验证就足够了，这意味着无论 HTTP 负载是什么，它们都可以工作。在 CSRF 攻击中，迷惑的代理(经过身份验证的浏览器会话)被诱骗执行一个未经身份验证的客户端(您)授权的恶意 HTTP 请求。你注意到前一句有提到 HTML 吗？

用 HTML 防御 CSRF 并没有错，因为它在某种程度上是不安全的，它是错的，因为它被误导了，因为它是在错误的地方防御。巧合的是，它对 JSON-over-AJAX 有效负载或任何其他非 HTML HTTP 请求也没有帮助，这些请求需要额外的变通方法来将 CSRF 令牌注入到每个有效负载协议的一些等效的 HTML 隐藏字段中。您可以在 XML 或 JSON 中添加额外的字段，但是祝二进制有效负载好运。从根本上说，CSRF 是一个 HTTP 级别的问题，因为这是在网络上建立权威的级别——理想情况下，应该在相同的 HTTP 级别上缓解这个问题。然而，实际的解决方案并不理想。

大多数 CSRF 防御方法都围绕着不可预测的每次会话令牌(1 <sup>st</sup> OWASP 语句)。这些令牌需要以某种方式验证有效性。这种验证可以有状态地或无状态地实现。在有状态方法中，服务器保持所有有效的先前发布/未过期的 CSRF 令牌的状态(ASP.NET 会话状态使用相同的模型)。有状态的方法不能很好地扩展，因为在单个会话期间可以有无限数量的 HTTP 交互，并且服务器端必须保持的状态量可能会快速增长，超出实际情况。无状态方法在客户端保留了服务器端验证 CSRF 令牌所需的一切，这不需要服务器端的状态，并且可以很好地扩展。无状态方法的缺点是需要向服务器端发送更多与 CSRF 相关的信息，因为服务器端是无状态的，但是这种额外的与 CSRF 令牌相关的膨胀通常是合理的。让我们探索无状态方法。

我们首先需要的是某种无状态 CSRF 令牌的客户端存储，HTTP cookies 是理想的选择。像[网络存储](http://en.wikipedia.org/wiki/Web_storage)这样的其他客户端存储机制是 HTML 概念——而不是 HTTP——因此已经过时了。更准确地说，我们希望用于存储的 HTTP 机制是 HTTP 头，cookies 是在 HTTP 头中存储自定义数据的一种受支持的协议。HTTP cookies 还有一个额外的好处(出于我们的目的)，即在每个 HTTP 请求中自动将它们存储的内容发送到服务器端。

接下来，我们需要一种方法来确保客户端存储的令牌的真实性，以防止攻击者制作自己的有效令牌。令牌的密钥 HMAC(基于服务器端密钥)将确保令牌的真实性。但是，HMAC 不会帮助重播令牌或攻击者成为合法用户，并使用自己的真实令牌发起 CSRF 攻击。这揭示了需要解决的两个重要问题——重放防止和令牌身份——我们理想情况下希望在 HTTP 级别解决这两个问题。有一个好的、经过测试的协议，我们可以在 HTTP 级别利用它来防止重放: [TLS](http://en.wikipedia.org/wiki/Transport_Layer_Security) 。我们可以通过给予令牌较短的生存时间(例如，包括一个绝对到期日期)来避免将 CSRF 令牌与身份捆绑在一起，这将使利用合法获得的令牌进行 CSRF 攻击变得更加困难。然而，这提高了难度，但并没有解决问题，因为坚定的攻击者只是及时获得了一个新的令牌。另一方面，将 CSRF 代币与客户身份联系起来，将彻底解决滥用合法发行的代币的问题。Windows 身份验证不允许将附加(动态)数据附加到身份，但表单身份验证允许。

无状态 CSRF 令牌方法还需要令牌提交的侧信道机制，攻击者不能利用该机制欺骗客户端(浏览器)生成有效的 HTTP 请求。侧通道角色由 OWASP 2 <sup>和</sup>语句中的 HTML 隐藏字段扮演，而主通道是基于 HTTP cookie 的(无状态模式)。然而，我们不想使用 HTML 表单域，除非我们真的必须这样做。我们需要一些合法浏览器可以完成的 HTTP 级别的“操作”，但是攻击者不能。

一种想法是基于这样的假设，即 CSRF 攻击者不能在混乱的浏览器的 HTTP 请求上注入或修改 HTTP 头，但是合法的自发起请求可以。这个假设的问题是，一些浏览器插件不按规则运行，能够绕过这个限制。

另一个想法是利用 [**同根政策**](http://en.wikipedia.org/wiki/Same_origin_policy) **(SOP)** 浏览器安全机制，这在现代网络浏览器中越来越难绕过。不可预测的 CSRF 令牌可以存储在客户端的防篡改加密认证 cookie 中(这是表单认证的功能)，标记为`HttpOnly`(不可读取)。同样的明文 CSRF 令牌值也可以存储在第二个 cookie 中**而不是**标记的`HttpOnly`，这允许标准操作程序批准的 JavaScript 读取它。需要 CSRF 保护的标准操作程序批准的 HTTP 请求将首先从明文 cookie 中读取 CSRF 令牌值，并将该值注入到传出请求的自定义 HTTP 头中，或者，如果头注入不可用，则将该值注入到有效负载中(这是一种让步，因为它不再是纯 HTTP 方法)。服务器端会将解密并验证的身份验证 cookie 容器中的 CSRF 令牌与侧信道(HTTP 头或嵌入有效负载)上提供的令牌进行比较，只有在匹配成功时才授权请求。

这种方法的好处是，即使目标浏览器有一个不按规则运行的插件，并且可以在传出请求上注入或修改 HTTP 头，该插件也不知道对正确的令牌值使用什么，因为对该值的访问还受到标准操作程序的保护。浏览器插件有可能绕过标准操作程序，但是浏览器从一开始就不安全。标准操作程序适用于 [DOM](http://en.wikipedia.org/wiki/Document_Object_Model) ，其中包括 cookies(通过`document.cookie`)以及任何 HTML 元素数据，如隐藏字段(通过`document.body`)。标准操作程序也适用于 [XMLHttpRequest](http://en.wikipedia.org/wiki/XMLHttpRequest) 。

这种方法可以通过在组合中添加过期时间来进一步加强。例如，表单身份验证令牌通常会有一个滑动到期时间，当旧的身份验证令牌即将到期时，会向客户端发送一个新的有效身份验证令牌。如果可以插入这个身份验证令牌重新颁发机制，我们还可以同时颁发一个新的 CSRF 令牌。这将分离网络会话、HTML 页面和 CSRF 令牌的生命周期，并缩短 CSRF 令牌的生命周期。

与更常见的 HTML 隐藏字段令牌存储方法相比，基于 cookie 的即时 CSRF 令牌注入有几个好处。一个好处是，CSRF 寿命不再与 HTML 寿命相联系，后者允许使用寿命更短、更安全的令牌。另一个好处是注入可以自动化，对开发人员来说是透明的，他们不再需要记住使用特殊的命令来为每个表单和 XMLHttpRequest 生成单独的 CSRF 令牌。身份验证和 CSRF cookie 会自动被颁发、重新颁发、轮换、过期等。对开发人员来说没有摩擦——它只是工作。有效负载操作仅在无法设置自定义 HTTP 头时使用；例如，在提交 HTML 表单时。

这是成功的秘诀——我们只需要合适的原料就能让这个秘诀发挥作用。具体来说，我们需要适当的机制来访问非`HttpOnly` CSRF cookie 值，并及时将其注入到 HTTP 头或表单提交中，就在传出的 HTTP 请求准备发出之前。及时的要求是由于身份验证和 CSRF 令牌 cookies 的预期异步循环。这需要一些 JavaScript 代码。HTTP 调用必须从某个地方触发，浏览器从 HTML 或 JavaScript 中触发它们(至少是改变服务器状态的调用)。我们需要在这些 HTTP 调用被触发之后，但在它们被发出之前拦截它们，所以我们使用一些 JavaScript 来实现它。我们正在使用 jQuery，但是它可以很容易地移植到原始的 JS 或者其他 DOM 操作的 JS 库。

代码清单 20

```cs
  function
  getCsrfToken() {
    // use
  your favorite cookie-reading logic to return the CSRF cookie value
  }

  /**************************************************************************
  Set up a
  prefilter for $.ajax() call to append a csrf header with the csrf token
  value, which is read from the csrf cookie prior to each $.ajax() call.
  The
  prefilter can further be overloaded via "beforeSend" function.
  The call
  sequence is (1) $.prefilter; (2) beforeSend (3) $.ajax() call.
  **************************************************************************/
  $.ajaxPrefilter(function
  (options, originalOptions, jqXHR)
  {
        var
  csrfToken = getCsrfToken();
        if
  (csrfToken)
        {
              jqXHR.setRequestHeader("X-CSRF",
  csrfToken);
        }
  });

  /**************************************************************************
  There is no
  way to add custom HTTP headers to non-AJAX requests, such as <form>
  POSTs. Instead, we auto-inject a hidden input element with CSRF token into
  every form on submit.
  **************************************************************************/
  var csrfName
  = "__csrf";
  var
  submitHandler = function (e, form)
  {
    form =
  form || this;
    if
  (form.method === "post")
    {
      var
  csrfToken = getCsrfToken(), $csrfInputElement;
      if
  (csrfToken)
      {
        $csrfInputElement = $("#" + csrfName, form);
        if
  (!$csrfInputElement.length)
        {
          var
  csrfHtml = '<input type="hidden" name="' + csrfName +
                       '" id="' + csrfName + '" value="' +
  csrfToken + '"/>';

  $(form).append(csrfHtml);
        }
        else
  $csrfInputElement["val"](csrfToken);
      }
    }
  };
  $(document).on('submit',
  'form', submitHandler);

  /**************************************************************************
  ASP.NET form
  submission is done via globally registered "__doPostBack" function.
  We need to intercept it and add CSRF-handling logic.
  **************************************************************************/
  var
  beforePostBack = function (beforeFunc)
  {
    var old__doPostBack
  = this["__doPostBack"];
    if
  (old__doPostBack)
    {

  this["__doPostBack"] = function (target, argument)
      {

  beforeFunc(target, argument);
        return
  old__doPostBack(target, argument);
      };
    }
  };

  $(function
  ()
  {

  beforePostBack(function (target, argument)
    {

  submitHandler(null, $("[name='" + target +
  "']").closest("form")[0]);
      return
  true;
    });
  });

```

我们不是 JavaScript 大师，但这段代码并不太复杂、通用，当然会自动执行所有客户端 CSRF 处理任务。我们还没有介绍服务器端 CSRF 令牌处理的机制。由于将 CSRF 令牌与身份验证联系起来有很多好处，因此我们应该首先深入查看表单身份验证，以便适当地设置阶段。

## 表单认证

**ASP.NET**[**表单认证**](https://en.wikipedia.org/wiki/Form-based_authentication) **(FA)** 是微软无状态实现的一种 [HTTP+HTML](https://en.wikipedia.org/wiki/HTTP%2BHTML_form-based_authentication) 认证技术。虽然这种技术非常流行和广泛，但它不是标准化的，完全依赖于实现。FA 中的客户端凭证(例如，用户名和密码组合)通常作为 HTML 有效负载的一部分“带内”发送到服务器端(例如，HTML 表单提交)。服务器端在成功进行凭据验证后生成一个身份验证票证，并且通常将该票证“带外”发送到客户端，通常是在 HTTP cookie 头中。随后的客户端请求也在带外提供该身份验证票证。然后，服务器端能够验证所声明的身份，以及身份声明的合法性，而无需任何额外的客户端凭据提交。

ASP.NET FA 可以在基于 cookie 或无 cookie 的模式下运行，其中[默认为](https://msdn.microsoft.com/en-us/library/system.web.configuration.formsauthenticationconfiguration.cookieless.aspx)是 ASP.NET 基于客户端设备声称的 HTTP 功能做出的运行时选择。Cookieless FA 充满了安全漏洞，所以最好通过强制始终使用基于 cookie 的 FA 模式来主动关闭它。FA 需要 TLS 来保证安全性，因此您必须确保所有基于 FA 的解决方案都 100%通过 TLS 交付。因为你不太可能仅仅因为读了前一句就真的去做，所以你需要适当的动机来激励自己和你的团队去实施 TLS。这个动机就是 [`RequireSSL`](https://msdn.microsoft.com/en-us/library/system.web.configuration.formsauthenticationconfiguration.requiressl.aspx) 属性，你应该设置为`true`，因为默认是`false`。`RequireSSL=true`导致 FA cookies 被标记为`Secure`，这阻止了合规的客户端代理(如现代浏览器)通过非 TLS HTTP 连接发送`Secure`标记的 cookies。因此，如果您不小心忘记部署 TLS，FA 将停止工作。正确部署顶级域名意味着“仅顶级域名，禁用超文本传输协议”，而不是“默认情况下，超文本传输协议工作正常。”然而，如果你设法把它搞砸了，HTTP 最终也能正常工作，`RequireSSL=true`可能会阻止一个漏洞利用。所有 FA cookies 都被标记为`HttpOnly`，这使得它们无法被兼容(现代)浏览器代理中的脚本访问。

默认 FA cookie [超时](https://msdn.microsoft.com/en-us/library/system.web.configuration.formsauthenticationconfiguration.timeout.aspx) **T** 为 30 分钟，[滑动到期](https://msdn.microsoft.com/en-us/library/system.web.configuration.formsauthenticationconfiguration.slidingexpiration.aspx)默认启用。每张饼干包装的 FA 票将在 **T** 分钟后过期，而任何有效的客户端提交的半衰期小于[的 FA 票](https://en.wikipedia.org/wiki/Half-life)生存时间(TTL) 将触发服务器端 ASP.NET FA 模块自动发行全新的饼干包装的 FA 票。该更新后的 FA 票证与 HTTP 响应一起发送到客户端，并购买 **T** 分钟以上的认证访问。如果就在半衰期 TTL 左右触发补票，有效的寿命延长只有~ **T** /2，因为旧的 FA 票本来还会多活一个~ **T** /2 分钟，而新发行的补票从发行时间起就对 **T** 分钟有好处。如果就在到期前触发了票证续订，则有效寿命延长为~ **T** 。

足总注销机制受到 ASP.NET 足总实施的无状态性质的限制。服务器端 FA 模块通过向客户端发送一个无效的、已经过期的 cookie 来实现注销，这将导致兼容的浏览器“忘记”他们一直持有的有效 FA 票证。然而，恶意客户端不必满足“请忘记您的有效票证”服务器端请求。这样的客户端可以继续使用之前获得的有效 FA 票证，服务器将会一直更新，没有问题。服务器停止接受并自动续订有效 FA 票证的唯一方法是使其无效，通常是通过更改用于 EtM 所有票证的全局服务器端密钥( [machineKey](https://msdn.microsoft.com/en-us/library/w8h3skw9(v=vs.100).aspx) )。这将使*所有先前发行的*足总票据无效，这意味着所有当前认证的用户都将被踢出。

足协票也不区分**发行日期**和**创建日期**，因为票内只记录发行日期。FA 票证跟踪的 [`IssueDate`](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.issuedate.aspx) 是票证创建的时间，无论这是第一个票证创建事件，还是后续的票证续订事件。换句话说，发行日期始终等于**到期日** ( [`Expiration`](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.expiration.aspx) )减去 **T** 分钟。某一张足总罚单被多次延期的事实在任何地方都无法捕捉到。这使得无法将最初在几分钟或几小时前创建的合法 FA 票证与几天、几个月或几年前创建的被利用的保活票证区分开来。如果一个改进的 FA 实现也能捕获创建日期，那就太好了，我们将创建日期定义为第一个原始的、未续订的票证创建的时刻(其中“续订计数”= 0)，但是 ASP.NET FA 实现并没有这样做。

一个显式的续订计数整数也会有所帮助，因为它不能从创建日期和到期日期之间的差异中明确推断出来。最后，唯一的固定资产会话标识将有助于识别每个唯一的固定资产会话。FA 会话标识可能是一个 GUID，因为它受到票证容器的保护，或者它可能是加密生成的(类似于会话状态会话标识)，因为在未受保护的使用场景中不可预测。

拥有唯一的固定资产会话标识将允许可选的服务器端状态。例如，大型服务器场中的每台服务器都可以在本地缓存与特定 FA 会话 ID 相关的一些信息(就像会话状态机制一样)，并且仅在缓存未命中时才转到延迟更高的数据存储。一个有用的场景是前往延迟更高的数据存储，以检查所提供的 FA 票证是否对应于有效身份(如未禁用的用户帐户)，并通过本地缓存最大限度地减少每个请求的数据存储行程。另一个有用的 FA 会话 ID 场景是透明的(没有用户参与)，针对低延迟数据存储重新验证客户端凭证，但仅在缓存未命中时。我们不希望使用任何用户特定的唯一标识(如用户标识)作为 FA 会话标识，因为我们应该理想地支持每个用户帐户的多个并行 FA 会话(例如，并发桌面和移动设备会话，或者只是多个浏览器并行登录)。

内置的 ASP.NET 4.5 FA 票证存储以下数据:

表 8:ASP.NET 4.5 表单认证票证内部

| **足协票数据** | **评论** |
| --- | --- |
| 序列化版本(1 字节) | 内部票证序列化的版本，可能是为了未来的序列化协议灵活性。当前设置为 1。内部。 |
| [票版](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.version.aspx) (1 字节) | 开发人员提供的任意票证版本，默认为 2。API 将其公开为`int`，内部转换为`byte`。如果您尝试将其设置为 256 并对其进行往返，由于静默字节转换，您将获得 0。MSDN 对此保持沉默，但 MS reference 源代码评论称如下:*“从技术上讲，它应该以 32 位整数的形式存储，而不仅仅是一个字节，但我们在历史上一直将它永远存储为一个字节，没有人抱怨。”*当然，这并不意味着它是正确的。 |
| [发布日期](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.issuedate.aspx) (8 字节) | 出票日期(原票或续票，如前所述)。 |
| 间隔符(1 字节) | 用于中断与 4.5 之前的 ASP.NET 门票的兼容性。内部。 |
| [失效日期](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.expiration.aspx) (8 字节) |  |
| [是版本](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.ispersistent.aspx) (1 字节) |  |
| [名称](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.name.aspx)(变长) | 用户提供。NET 字符串，字符序列化。 |
| [用户数据](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.userdata.aspx)(可变长度) | 用户提供。NET 字符串，字符序列化。默认为空字符串。 |
| [Cookie 路径](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthenticationticket.cookiepath.aspx)(可变长度) | 用户提供。NET 字符串，字符序列化。默认为。配置值。 |
| 间隔符(1 字节) | 另一个间隔打破兼容前 4.5 ASP.NET 门票。内部。 |

Pre-ASP.NET 4.5 FA 票证实现具有不同的序列化格式和不同的身份验证对称加密方法，这在 2011 年遭受了危及每个版本的的[关键安全漏洞](https://technet.microsoft.com/library/security/ms11-100)。NET FA，需要带外补丁。这个严重的漏洞已经存在了七年多。ASP.NET 4.5 使用了一种新的序列化格式(从安全角度来看并不重要)和一种新的 EtM 加密方法，这种方法最终被正确地完成(类似于我们描述的 EtM 方法)。仅此一点就足以成为运行 ASP.NET 4.5 的令人信服的理由。

ASP.NET 足总的球票在历史上被编码为 Base16，这不会随着 ASP.NET 4.5 而改变。微软继续支持无 cookie 的 FA 模式，这可能是不区分大小写的 Base16 票证编码的原因。遗留兼容性是一件不好的事情。不幸的是，所有基于 ASP.NET cookie 的 FA 部署都必须付出 Base16 膨胀的代价。如果 ASP.NET 足够聪明，能够对无 cookie 的 FA 票证使用 Base16 票证编码，对基于 cookie 的 FA 票证使用 Base64 编码，那就太好了。从 Base16 切换到 Base64 会将编码的 FA 票证大小减少 33%，并将存储密度提高 50%。给定最大 4 千字节的 HTTP cookie 大小，Base16 最多可以存储 2 千字节，而 Base64 最多可以存储 3 千字节——这是一个额外的千字节存储(例如，序列化的 512 字节。NET 字符串)。

### 会员资格

FA 票证的身份携带部分是强制的`Name`字符串属性，应该设置为唯一的客户端身份。这个唯一的身份应该被设置为凭证验证的一些黑盒过程的结果，这超出了 FA 的范围。这种凭证验证过程通常包括三个阶段:

*   注册(凭据创建和存储)
*   提交(为认证目的提供证书)
*   验证(验证提交的证书)

ASP.NET 在一个单独的“[成员资格](https://msdn.microsoft.com/en-us/library/yh26yfzy(v=vs.100).aspx)应用编程接口中实现这些证书管理阶段，该接口可以有多个“提供者”(实现)。ASP.NET 附带了 SQL Server 和活动目录成员资格提供程序。还有一个抽象的`WebMatrix.WebData.dll`中带有 [`SimpleMembershipProvider`](https://msdn.microsoft.com/en-us/library/webmatrix.webdata.simplemembershipprovider(v=vs.111).aspx) 实现的 [`ExtendedMembershipProvider`类，以及一个单独的只提供](https://msdn.microsoft.com/en-us/library/webmatrix.webdata.extendedmembershipprovider(v=vs.111).aspx)[通用](https://nuget.org/packages/Microsoft.AspNet.Providers)提供者的 NuGet 微软包，其中“通用”部分似乎指的是紧密耦合的 SQL Server 持久性被交换为基于紧密耦合的 Entity Framework 持久性的事实，后者支持一些额外的存储后端。

从安全角度来看，`SimpleMembershipProvider`是微软提供的唯一尝试做正确事情的成员实现，例如使用计算速度慢的基于密码的密钥派生。从设计和可用性的角度来看，成员资格是一个古老的 API，在 2005 年可能会有用，但当根据现代安全工程设计原则进行评估时，它就不再足够了，因为它存在安全性不足、多次 [SRP](https://en.wikipedia.org/wiki/Single_responsibility_principle) / [SoC](https://en.wikipedia.org/wiki/Separation_of_concerns) 违规以及紧密的持久性耦合等问题。虽然微软试图解决`SimpleMembershipProvider`的一些问题，但这充其量只是一个暂时的解决方案。除了使用更现代的凭据管理应用编程接口之外，根本没有好的方法来解决成员资格不足的问题。各种 ASP.NET 技术(如网络表单、MVC、网页和网络应用编程接口)之间的凭据管理也不一致。

### 内部威胁

一个重要的安全目标是防御内部威胁—攻击者或当前和以前的员工，他们可能能够从内部访问您的宝贵数据，并且应该假设他们具有完全的内部知识和完全的服务器端读取权限(包括完全了解所有密钥、完全的数据库读取权限等)。).这是一个很难达到的安全目标，但作为深度安全防御方法的一部分，至少有必要建立一些防御机制来挫败内部威胁。我们敢说，会员资格和所有其他 ASP.NET 安全机制都不是为了防范内部威胁而设计的。

“只有两种类型的公司:已经被黑的公司和将要被黑的公司。即便如此，这也正在合并成一个类别:那些已经被黑客攻击并将再次被黑客攻击的类别。”

联邦调查局局长罗伯特·穆勒(2012 年 3 月 1 日)

安全专家倾向于更悲观的观点，认为只有两种公司:被黑客攻击的公司和不知道自己被黑客攻击的公司。关注`SimpleMembershipProvider`内的[高级持续威胁(APT)](https://en.wikipedia.org/wiki/Advanced_persistent_threat) 暴力迫使“弱”1000 次迭代的 PBKDF2-SHA1，而忽略上周被解雇的初级开发人员是不合理的，该开发人员已经看到了`<machineKey>`秘密密码，因此能够伪造任何所需的 FA cookie 和身份，因为您从未更改过`<machineKey>`密码。即使您有更改秘密密码的策略，并费心在您的 100 台服务器的 web 服务器场中实际推出新密码(当然，您只需单击一下就可以轻松完成，因为在您的公司，一切都是如此完美地自动化，几乎可以自己运行)，您也必须等待一两周，直到下一次计划的生产推送。

这个假设的场景并不是那么牵强，可能是一个严重的安全威胁。虽然内部人员可能不是特别先进、老练或恶意，但他们的坚持和持久性，加上猖獗(故意)的无知、无能、糟糕的培训和资金不足，足以弥补这一点(安全很少产生收入)。虽然 APTs 在资金充足时更危险，但内部人士在资金不足时通常更危险。拥有正确的心态对于缓解内部威胁至关重要，最好的方法是假设攻击者是“你”，或者更确切地说，是来自平行宇宙的邪恶的自己，他知道你所知道的一切，并且拥有对你所拥有的一切的读取权限。

## 凭证存储

我们已经介绍了从低熵 SKM 导出主密钥(MK)的 PBKDF2，例如用户密码。PBKDF2 强制您提供一个盐(例如，一个 GUID)，所以您不太可能忘记保护 MK 不被 SKM 重用。这时，您可以根据用户记录存储 MK 和 salt，事实上许多系统都是这样做的。然而，我们建议不要这样做。

一个问题是，此时除了存储之外，没有任何东西将 MK 连接到用户标识。理想情况下，MK 应该通过加密与用户标识相关联，而不仅仅是通过存储。假设内部人员对用户标识具有只读访问权限，对 MK 和 salt 具有读写访问权限，则可以用另一个 MK/salt 记录(来自内部人员自己的具有已知密码的帐户)替换一个 MK/salt 记录(对于“管理员”用户)，以获得访问权限，并可能将其改回以避免被发现。

另一个问题是，在密钥提取/派生和存储之间进行显式的单向转换是明智的，如果直接存储 PBKDF2 派生的结果，则可以跳过这一转换。进行这种显式单向转换的一个原因是为了干净利落地获得 MK 的图像和预图像，例如，PBKDF2 派生的秘密可以是 MK (PMK)的预图像，而 PMK 的单向图像可以是保存到存储中的实际 MK。

生成 MK 的一个显而易见的想法可能是 MK = HASH(PMK)，其中 HASH 是一个类似 SHA-512 的加密 HASH。这没有解决我们加密连接 MK 和用户 ID 的愿望，所以不要这样做。另一个想法可能是 MK = HASH(PMK + <user id="">)或 HASH( <user id="">+ PMK)，其中+是串联。这个想法很可能受到[长度延长攻击](http://en.wikipedia.org/wiki/Length_extension_attack)的影响，所以也绝对不要这样做(即使是 SHA-384)。有一个合适的加密工具可以用一个秘密密钥来验证数据:MAC，以及我们首选的 MAC 实现，HMAC。我们可以做 MK = HMAC <sub xmlns:epub="http://www.idpf.org/2007/ops">PMK</sub> ( <用户 ID >)。这是我们的首选方法，因为它确保了单向的 PMK 到 MK 转换，同时将 MK 与用户 ID 加密绑定。</user></user>

| ![](img/tip.png) | 提示:一般来说，不要通过创造性地在散列的消息中注入秘密来使用散列来代替 MAC。 |

我们根据用户 ID 记录存储 MK 和 salt，但是我们应该如何处理 PMK 呢？各种 ASP.NET 会员提供商对 PMK 没有单独的概念，因为他们跳过了 PMK 到 MK 的步骤。PMK = MK 对他们来说。这些成员资格提供者也只对服务器端存储进行一次 MK 验证:在(成功)登录期间第一次生成 FA cookie 时。后续的 FA cookie 提交基于服务器端使用固定的服务器端密钥(或派生密钥)对 FA cookie 进行 EtM 解密的能力进行验证。只要 EtM-解密成功，FA cookie 就被接受为有效，并且由这种 FA cookie 内容做出的所有声明都被接受。实际上，ASP.NET 安全模型用一个秘密的、用户提供的密钥来交换一堆身份声明，这些声明是用服务器端的秘密密钥签署的，外人不应该知道，这防止了外人伪造身份声明。请注意，服务器端身份存储不是身份声明验证的一部分，验证身份声明所需要的只是 EtM 解密尝试。然而，内部人员被认为知道所有秘密的服务器端密钥，因此能够伪造任何身份声明，因为他们知道使 EtM 解密成功所需的秘密密钥。

ASP.NET FA 安全模型的一个明显的优点是，它可以很好地扩展，因为它不会为每个登录后请求咨询服务器端存储进行身份声明验证。这种方法的明显缺点是，内部威胁显然超出了这种安全模型的范围。ASP.NET 足总无法在注销时使票证无效(我们之前讨论过)，这是不存在登录后服务器端凭据验证的直接后果。如果有一个更强大的 FA 安全模型，能够抵御内部威胁，并允许在始终检查存储以验证登录后的客户端请求和从不检查存储(ASP.NET FA)之间进行微调和达到最佳平衡，这不是很好吗？这是 PMK 可以提供帮助的地方。

当用户使用用于派生 PMK 的凭据登录时，我们可以将 PMK 存储在 EtM 加密的 FA 票证容器中(例如，存储在`UserData`字符串中)。随后的客户端-服务器交互将通过以下方式进行验证:(1)ETm-用服务器端密钥解密 FA cookie(2)从 FA cookie 中提取 PMK 和<用户标识>声明，并根据该特定用户标识的服务器端存储记录检查 HMAC <sub>PMK</sub> ( <用户标识>)。内部人员可能能够绕过(1)使用服务器端密钥的知识，但是他们将更难绕过(2)，因为这将需要知道用户的 PMK，或者能够在存储中永久或临时伪造<用户标识>。

对于将敏感数据存储在 cookies 中，大多数下意识的反应(称为“互联网建议”)通常是这样的:

1.  用 TLS 搭配`Secure`、`HttpOnly`饼干。
2.  加密你的饼干。
3.  不要这样做。

TLS 的必备要求是声音。如果有人能偷到一个有效的(未过期的)FA cookie，那么里面是什么并不重要。加密要求在技术上不是必须的，因为 cookie(即其媒体访问控制)的真实性通常比其内容的隐私性更重要。然而，我们确实想加密我们的 cookie，因为 EtM 加密不仅给了我们隐私和真实性，还允许我们利用 cookie 容器来存储真正需要隐私的数据，例如 PMK。然而，“不做”部分是[恐惧、不确定和怀疑](http://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt)的结果。

PMK 是一个适当加盐的、PBKDF2 衍生的(并且充分迭代的)固定长度值。假设 cookie 容器的 TLS 保护和 EtM 加密都以某种方式被绕过(正确实现的加密很少被破坏，并且通常被绕过)，PMK 只能对内部人员有用，因为外部人员不能伪造 FA cookies。PMK 知识没有揭示登录所需的实际明文用户密码。如果用户的明文密码碰巧很容易预测，那么无论如何都不会有助于阻止攻击者。

## 改进表单认证

我们已经在前面的章节中描述了 ASP.NET 4.5 FA 的缺陷及其票箱内容。让我们总结一下这些不足，我们将努力纠正这些不足:

*   空间效率低的 Base16 容器编码。
*   不是为了抵御内部攻击而设计的:
*   没有到用户凭据的加密连接。
*   凭据验证只进行一次(登录时)。
*   没有单独创建日期和(重新)发行日期的概念。
*   没有(重新)发行计数的概念。
*   没有唯一会话标识的概念来标识每个唯一的固定资产会话，这在票证重新发行后仍然存在。
*   不是为了给 CSRF 提供防御。

我们将采用以下方法来改善这些缺陷:

*   使用 Base64 容器编码。
*   通过以下方式抵御内部攻击:
*   将用户凭据派生的 PMK 添加到足总票证。
*   根据需要添加自定义逻辑挂钩来触发凭据验证。
*   向固定资产票证添加创建日期—(重新)发行日期已被捕获为`IssueDate`。
*   将重新发行计数(无符号整数)添加到 FA 票证。
*   向固定资产票证添加唯一的会话标识。
*   通过以下方式为 CSRF 辩护:
*   在足总的门票上增加了一个不可预测的 CSRF 代币，每次重新发行时都会重新生成。
*   添加第二个 cookie，它具有 JavaScript 可读的 CSRF 标记值，与 FA cookie 进行了生存期同步。

我们想要添加到 **FA** 票证容器中的附加数据必须以对应用编程接口透明的方式存储在`UserData`字符串中，以便使用应用编程接口的用户可以继续按照其文档指定的方式将用户提供的数据存储在`UserData`字符串中。让我们看看我们的存储需求可能是什么样的:

表 9:可选表单身份验证票证内部

| **数据** | **大小(字节)** | **评论** |
| --- | --- | --- |
| 编成日期 | eight | `DateTime`结构为二进制。 |
| 发行计数 | four | `UInt32`。 |
| 会话标识 | Sixteen | 128 位随机 CSP 生成。 |
| CSRF 令牌 | Fifteen | 120 位随机 CSP 生成。 |
| 用户证书衍生的 PMK | Thirty-two | PBKDF2-HMAC-SHA-512/256(即仅最左边的 256 位)。 |
| **总计** | **75** | 作为字节数组。 |
| **Base64(总计)** | **100** | 作为`UserData`-存储的字符串。 |
| **文字连载** | **200** | 将字符串大小加倍为字节数组。 |
| **碱基 64 编码的饼干** | **~267** | 添加到 FA cookie 容器中。 |

如您所见，由于 FA 票据 API 不支持直接字节数组存储，在`UserData`字符串字段上搭载会导致大量存储开销。如果直接字节数组存储对我们可用，我们将只需要最终 cookie 容器的一个 Base64 编码——1.33 倍的膨胀因子，而不是 3.56 倍。

从积极的一面来看，所有的字段都是固定长度的，这意味着我们可以很容易地在用户提供的`UserData`中添加和取消添加它们的 Base64 编码值。算法灵活性可以通过现有的强制`Version`字节字段来实现。

120 位 CSRF 令牌的安全强度应该足够了，因为使用默认的 ASP.NET 滑动到期设置，CSRF 令牌的单个足总票证发行寿命为 30 分钟。

从安全角度来看，最好使用完整的 512 位 PMK。然而，64 字节是承载每一个 FA cookie 的沉重负载，这将通过 1.33 × 2 × 1.33 = 3.54 的乘数进一步膨胀到 227 个 cookie 字节。使用截短的 256 位PMK 将额外的 cookie 有效负载减少了一半(至 113 字节)，同时仍然提供足够的用户密码熵提取和安全余量。

给定一个 256 位的 PMK，服务器端将存储 MK**= HMAC-SHA-512/256<sub>PMK</sub>(<用户 ID>)—即用户 ID 的 PMK 键控 512 位 HMAC，被截断为 256 位。服务器端没有用户的 pmk 记录是至关重要的。每个经过身份验证的客户端请求将向服务器端提供一个 PMK 声明和一个用户标识声明。然后，服务器端完全有权信任这些声明，因为 EtM 解密是成功的(弱声明身份验证)，或者，通过计算 MK 并针对声明的用户标识的存储进行验证(强声明身份验证)来做更多的工作。内部人员可以绕过弱身份验证，但不能绕过强身份验证。**

 **包含唯一的、不可预测的会话标识也有助于通过缓存层降低 PMK 到 MK 验证的成本或延迟。只有当会话标识不在缓存中时，才能触发 PMK 到 MK 的验证；否则，由于之前的 PMK-MK 验证，足总票据被视为强认证。有许多分布式内存缓存解决方案可供使用。NET(免费和商用，来自微软和其他供应商，基于云和服务器)，具有不同的一致性功能。即使一致性不是完美的，可能发生的最糟糕的情况是额外的 PMK-到-MK 验证—当缓存一致性失败时，不会出现安全故障。简单的场景甚至可以使用 [`ConcurrentDictionary`](https://msdn.microsoft.com/en-us/library/dd287191.aspx) 进行会话 ID 缓存。

我们的安全模型假设内部人员对所有服务器端密钥具有只读访问权限，对所有服务器端存储具有只读访问权限，但对应用程序或 web 服务器内存没有访问权限。即使内部人员对内存中的会话标识缓存具有读写权限，缓存的会话标识也是匿名的。无法确定特定会话标识属于特定登录用户，也无法预测或“修复”新登录的会话标识。您应该避免在`ConcurrentDictionary`中使用固定资产票据作为值，因为这将取消会话标识的匿名化。

您可能会考虑使用一个定制的 FA 票证容器，该容器不会受到 ASP.NET FA 票证 API 膨胀的影响，因为您现在已经确切地知道您想要包含什么数据，以及如何序列化、存储、编码和加密它。然而，我们建议不要这样做，除非 ASP.NET 足总的机票存储和处理对您来说是您已经衡量过的严重瓶颈，并且您已经用尽了所有其他优化途径。在 ASP.NET 足球协会宣传材料的基础上增加的主要原因是保证以下几点:

*   微软的实现是成熟的(经过时间考验的)，从安全的角度来看是合理的。
*   微软为您维护它，并将比您更快更好地解决任何安全问题。
*   如果将来有任何严重的问题被发现，ASP.NET 足总将会被全世界的所有人打破。头条将是关于微软，而不是你的公司。你可以支持“遵循微软的指导方针”，而不是为你的定制实现的优点和理由辩护。在极端情况下，微软甚至可能对你的公司负责。

触发强声明身份验证的决定是完全灵活的，可能取决于以下因素:

*   会话标识缓存未命中。
*   足协票续签。
*   足总票据发行计数超过某个非典型阈值。
*   通过 *N* 增量(即每 *N* <sup>第</sup>次补票)的足协票发行计数。
*   固定资产票证有效期(到期日减去发行日)高于某个阈值。
*   CSRF 令牌验证失败(这本身应该会阻止请求的操作，但在这种情况下，您可能还想检查并记录任何强声明身份验证失败)。
*   基于 IP、基于角色/权限、基于操作或任何其他自定义逻辑。

## 新 ASP.NET 密码栈

由于之前的 ASP.NET 版本存在严重的安全漏洞，ASP.NET 4.5 加密代码路径已经进行了重大改进。在列维·布罗德里克的“ASP.NET 4.5 中的密码改进”MSDN 博客文章的[第 1 部分](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)、[第 2 部分](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)和[第 3 部分](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)中对这些变化进行了充分的描述。旧的`MachineKey.Encode`和`MachineKey.Decode`方法已经被新的 [`MachineKey.Protect`](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.protect.aspx) 和 [`MachineKey.Unprotect`](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.unprotect.aspx) 方法所淘汰，这些方法使用适当的 KDF 和粒度的、上下文驱动的主密钥派生来进行适当的 EtM。

代码清单 21

```cs
  static
  byte[] Protect(byte[] userData, params string[] purposes)
  static byte[] Unprotect(byte[]
  protectedData, params string[] purposes) 

```

`Protect`、`Unprotect`使用的秘密加密验证主密钥自动来源于`<machineKey>`配置设置，就像`Encode`、`Decode`一样。这种隐式的主密钥配置使得`Protect`和`Unprotect`API 更容易使用，更难滥用或误用。不幸的是，这种无法使用外部提供的主密钥也大大限制了`Protect`和`Unprotect`应用编程接口的实用性。人们可能会试图通过使用固定的`MachineKey`密钥并通过`purposes`数组提供定制的外部主密钥来“破解”这一限制。虽然我们不能确认或否认这种方法的安全性或不安全性，但我们知道`purposes`数组被设计为非秘密识别器，而不是秘密密钥。滥用这种设计与滥用 HMAC 的消息保密性没有什么不同:它可能会起作用，但除非专业密码学家告诉你它起作用，否则你应该避免任何滥用密码设计和 API 的行为。

ASP.NET 4.5 允许完全替换`Protect`和`Unprotect`方法使用的加密黑盒(因此实际上是所有的 ASP.NET 加密)，以将`userData`转换为`protectedData`并返回。这种替换是通过一个新的抽象 [`DataProtector`](https://msdn.microsoft.com/en-us/library/system.security.cryptography.dataprotector) 类的任何具体实现来实现的。配置文件指令使用这样的`DataProtector`实现代替默认的 ASP.NET 4.5 加密。你可以通过做一个简单的`DataProtector`实现来试验这个特性，这个实现返回一个明文字节数组作为密文字节数组，反之亦然——纯粹是为了学习，只是为了感受一下。

`DataProtector`替换功能是一个很好的备份计划，以防在 ASP 中发现重大安全漏洞。NET 的实现或 ASP.NET 使用的加密原语。它仍然不能帮助我们定制外部提供的秘密主密钥，因为`Protect`和`Unprotect`API 仍然是唯一可用的高级 API。幸运的是，我们可以利用[火海](http://securitydriven.net/inferno/)库中合适的 EtM 实现，它没有隐式键限制。基于火海的`DataProtector`实现也恰好比微软默认的`Protect` / `Unprotect`加密快 15%左右，尽管这并不是一个足够好的理由去喜欢它，除非对速度的需求压倒了你所有的其他考虑。

## ASP.NET CSRF API

ASP.NET 4.5 自带的 CSRF 防御 API 位于 [`AntiForgery`](https://msdn.microsoft.com/library/system.web.helpers.antiforgery(v=vs.111).aspx) 静态助手中，其中提供了两个方法对:

*   `HtmlString GetHtml()`
*   `void Validate()`

...还有…

*   `void GetTokens(string oldCookieToken,out string newCookieToken,
    out string formToken)`
*   `void Validate(string cookieToken,string formToken)`

MSDN 有如何使用第一对方法的基本信息，但没有第二对方法。关于这些 API 是如何设计工作的信息也非常少，这使得正确使用它们非常困难。我们先来复习一下`AntiForgery`力学。有两个“令牌”在起作用:一个 cookie 令牌和一个表单令牌。

表 10:ASP.NET 防伪令牌内部

| **饼干代币** | **表单令牌** |
| --- | --- |
| 1 字节令牌版本，设置为 1。 | 1 字节令牌版本，设置为 1。128 位(16 字节)CSP-随机值。 |
| 128 位(16 字节)CSP-随机值。1 字节`IsSession`标志，设置为 1。 | 1 字节`IsSession`标志设置为 0。基于声明(1)还是不基于声明(0)的 1 字节标志。基于上述标志的声明字节或用户名字符串(UTF-8)。附加数据字符串(UTF-8)或 0 字节(如果不存在)。 |
| 总大小(预加密):18 字节 | 总大小(预加密):最小 21 字节 |

cookie 和表单令牌之间的绑定是通过它们的 128 位 CSP-random 值来完成的，这两个令牌必须相同才能推断出有效的绑定。cookie 和表单令牌都经过 EtM 加密和 Base64 编码，成为最终的字符串值。没有加密 cookie 令牌的真正需要，因为其中没有任何秘密，但微软还是这样做了，可能是为了验证它(EtM 的 M 部分)。这种不必要的加密给 cookie 令牌增加了很多膨胀，cookie 令牌会在每个 HTTP 请求中传播(这是累加的)。

ASP.NET CSRF 令牌没有与 ASP.NET 身份验证和授权机制集成。您可能会认为它们是新的可选的 ASP.NET 特性，没有依赖性，这是可以理解的，因为这就是它们的文档所暗示的。现实是，ASP.NET·CSRF 的代币从根本上与`HttpContext.Current.User.Identity`控制的语境身份联系在一起。如果您的应用程序在`HttpContext`上设置身份，那么 ASP.NET CSRF 令牌会将该身份编码到表单令牌中，并在稍后根据当前的`HttpContext`对其进行验证。但是，大量的 ASP.NET 应用程序都有自定义的认证逻辑，而不是由`HttpContext.Current.User.Identity`驱动的。只有当`HttpContext.Current.User.Identity`存在并拥有`IsAuthenticated=` `true`时，ASP.NET CSRF 表单令牌才会捕获并验证身份。

下面的代码将设置一个通用的“空字符串”标识，它有`IsAuthenticated=` `false`:

代码清单 22

```cs
  HttpContext.Current.User = new
  GenericPrincipal(
      new GenericIdentity(""), null);

```

如果`HttpContext.Current.User.Identity`为空或者有`IsAuthenticated=` `false`，表单令牌会将一个空字符串编码为标识——它不会抛出或以其他方式提醒您。这是危险的，因为它使来自所有用户的 CSRF 令牌可以互换，并允许现有用户相互发起 CSRF 攻击。因此，ASP.NET·CSRF 令牌 API 并不是现成的，因为它们需要特定的身份管理方式。微软的文档中没有提到或涵盖这种依赖关系，但即使有文档记录，它也只会强调微软的 CSRF 令牌实现是一种事后的想法，它不如通过设计将 CSRF 防御机制与身份和身份验证集成在一起的替代方法。

例如，我们在[“改进表单身份验证”](#_Improving_forms_authentication)一节中描述的 15 字节 CSRF 令牌将 Base64 编码为 20 字节。相比之下，微软的 18 字节 CSRF 令牌将 EtM 加密为 108 字节:

18 字节→ 32 (AES 填充)→80(IV 16 字节；32 字节的 MAC) → 108 (Base64)

另一个问题是，ASP.NET CSRF 令牌是受身份限制的，而不是受会话限制的。想象一下推特正在运行 ASP.NET(试试)。您刚刚注册了@Ironman 帐户。然而，在你不知道的情况下，有人之前已经有了@Ironman 账号并删除了它，这让你可以抓取它。有人拥有@Ironman 身份的有效 CSRF 令牌，并且可以对您的帐户发起 CSRF 攻击—永远。

为什么是永远？ASP.NET·CSRF 令牌的另一个问题是它们没有过期(会话过期，身份不过期)。表单令牌旨在存在于 HTML 中，HTML 也不会过期。使已经发行的 ASP.NET·CSRF 令牌无效的唯一方法是更改服务器上的 ASP.NET 机器密钥。

您可以通过将 ASP.NET CSRF 令牌绑定到会话来解决这个问题。一种方法是使用独特的身份。独特的身份是不受会话限制的，但提供了一些防御 CSRF 令牌重播。虽然新旧 Twitter @Ironman 句柄是相同的，但是您会在内部用不同的 GUIDs 来标识它们，这些 GUIDs 会成为真正的内部帐户身份。另一种方法是利用表单令牌的`AdditionalData`属性。您可能希望在此属性中存储一些特定于会话的标识符。但是不能直接设置，只能通过设置 [`AntiForgeryConfig.AdditionalDataProvider`](https://msdn.microsoft.com/en-us/library/system.web.helpers.antiforgeryconfig.additionaldataprovider(v=vs.111).aspx) 来设置，需要实现 [`IAntiForgeryAdditionalDataProvider`](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 界面。

使 CSRF 令牌与会话绑定，而不仅仅是与身份绑定(即使身份是唯一的)，对于内部威胁模型也很重要，内置的 ASP.NET 组件很少考虑这一点。对机器密钥具有读取权限的内部人员可以为任何已知身份(如“管理员”)生成永久有效的 CSRF 令牌要使 CSRF 令牌绑定到会话，需要内部攻击者猜测特定身份的有效、短暂的会话标识符，这可能是一项困难得多的任务。不要使用 ASP.NET 会话标识符作为您的会话标识符，因为它们可能被攻击者在客户端修复(根本不要使用 ASP.NET 会话)。客户端会话固定将使攻击者能够生成特定的已知会话，并诱骗受害者使用该会话，而不是随机的不可猜测的会话，因此请确保您已经解决了该威胁。

由于微软的 CSRF 令牌使用 ASP.NET 加密堆栈进行 EtM 加密。NET 4.5 产生的令牌将非常不同，并且与早期版本产生的令牌不兼容。NET Framework 版本(参见我们在“[新 ASP.NET 加密堆栈”](#_New_ASP.NET_crypto)一节中的讨论)。那个。NET 4.5 加密堆栈仅在 [`HttpRuntime.Targetframework`](https://msdn.microsoft.com/library/system.web.httpruntime.targetframework.aspx) 返回“4.5”版本对象时由微软的 CSRF 令牌逻辑使用——否则，使用 4.5 之前的加密 API。在 ASP.NET 应用程序中，可以通过。配置文件设置，正如[这篇博文](https://blogs.msdn.microsoft.com/webdev/2012/11/19/all-about-httpruntime-targetframework/)所解释的。可惜的是`<httpRuntime targetFramework>`。配置设置对 non-ASP.NET 应用程序没有影响，该应用程序将默认为`HttpRuntime.TargetFramework=4.0`，即使是为编译并运行时也是如此。NET 4.5。强制 non-ASP.NET 应用程序继续运行的一种方法。NET 4.5 进入生产基于 4.5 的 CSRF 令牌是:

代码清单 23

```cs
  AppDomain.CurrentDomain.SetData("ASPNET_TARGETFRAMEWORK",
              new
  FrameworkName(".NETFramework", new Version(4, 5)));
  HttpRuntime.TargetFramework.Dump();
  // Version 4.5 now

```

## 客户端 PBKDF

使用 PBKDF 和类似的基于密码的 KDF 方案从低熵密码中导出密钥的一个明显的后果是它们故意的高计算成本，以 CPU 利用率和/或内存利用率来衡量。这一成本可能很快成为服务器端吞吐量的限制因素(例如，以每秒请求数衡量)。

一个诱人的想法是将 PBKDF 计算从服务器端转移到客户端。让我们仔细研究一下为什么这个想法会失败。与服务器端基础架构相比，典型的客户端设备往往具有较差的 CPU 和内存资源。客户端软件通常甚至不能充分利用可用的客户端资源。许多现代浏览器被卡在 32 位模式下，即使它们运行在 64 位环境中(也就是说，它们无法充分利用可用内存)。即使浏览器在 64 位模式下运行，它们的计算能力通常也会受到单线程 JavaScript 引擎的限制(它们无法充分利用可用的 CPU)。移动客户端设备通常主要由电池供电，并且其资源能力甚至进一步受限。

客户端资源劣势的关键含义是，与服务器端执行相比，可接受可用性的客户端 PBKDF 回合数通常要低得多。PBKDF 回合数量的任何大幅减少都将削弱 PBKDF 的安全性，并规避其预期目的。

另一个问题是 PBKDF 是加盐的(如果不是，那你用的不对)。Salt 值在服务器端可用(这使得服务器端 PBKDF 变得简单)，但在客户端不可用。向客户端发送 salt 值不仅会增加复杂性，还会削弱安全性。虽然盐的价值不一定要保密，但也不应该愉快地透露给任何提出要求的人。对手可能会要求“管理员”帐户的盐值，并将其与常见密码列表相结合，以生成潜在的凭据并快速发起在线攻击。公开盐的价值显然不符合我们的最佳利益。

## 密码重置

密码重置协议试图为用户提供一种“可接受的安全”方式来重置或更改你所知道的认证器(密码)*，而无需*提供有效的现有认证器，这破坏了这种认证器的整个目的。因此，重要的是要认识到，大多数密码重置协议都是有意削弱您试图保护的系统安全性的一种做法，并且通常是安全措施链中最薄弱的一环。

由于实用性(易于使用、易于管理以及易于授权和撤销)，密码验证器往往是许多系统中帐户所有权的唯一“证明”。这些系统唯一安全的密码重置协议实际上是“*密码更改/重置需要现有密码的知识证明。*“如果现有密码丢失，当现有密码是唯一的所有权证明时，就没有办法正确建立账户所有权。在野外使用的各种密码“替代方案”——如电子邮件、短信和自动电话——只是通过将其外包给另一个外部系统或将其拆分给几个外部系统(更改或重置密码都需要电子邮件、短信和语音呼叫代码)来避免建立帐户所有权的问题。

大多数用于自动身份确认和密码重置的辅助通道安全性较弱或没有安全性。使使用这些不安全的边信道的风险略微可信的唯一缓解因素是通过这些信道发送的身份确认令牌的生存时间短。典型侧信道的另一个严重问题是它们的安全性通常是相互依赖的。由于登录的电子邮件客户端，被盗的智能手机很可能允许对手接收电话、短信和阅读所有者的电子邮件。

如果您别无选择，并且为了可用性必须削弱系统的安全性(当用户无法向现有或声称的帐户提供有效凭据时，要求用户创建新帐户对业务不利)，那么您可能会首先尝试利用电子邮件端渠道，因为您可能已经在使用该渠道进行用户沟通。我们现在将描述你应该如何以最少的方式做这件事。

基于电子邮件的密码重置过程有两个不同的阶段:令牌请求和令牌验证。

令牌请求:

1.  询问帐户链接的电子邮件地址和验证码解决方案。
2.  如果验证码被解决，并且电子邮件正好匹配一个帐户:
3.  生成一个 CSP-随机令牌 **T** (120 位就够了)及其创建 UTC 时间戳 **TS** 。
4.  用 **T** 作为密钥计算签名**SIG**=**HMAC<sub>T</sub>T7】(账号 ID + **TS** )。**
5.  在数据库中记录 **SIG** 和 **TS** (但不记录 **TK** )。
6.  发邮件 **Base64** ( **T** )尽快忘记 **T** 。

令牌验证:

1.  从用户处获取**T**—例如，用户点击带有嵌入式 **Base64(T)** 的电子邮件发送的网址。
2.  从用户处获取帐户 ID 或用户名(不要在电子邮件中透露)和验证码解决方案。
3.  如果验证码被解决并且 **TS** (查找声明的账户 ID)有效:
4.  计算**SIG '**=**HMAC<sub>T</sub>T5】(账号 ID + **TS** )。**
5.  比较 **SIG'** 和 **SIG** (查找索赔账户标识)。如果 **SIG'** = **SIG** :
6.  要求用户选择新密码。
7.  重置**签名**和**终端服务**以针对该帐户标识为空。
8.  发送“您的密码已被更改”通知电子邮件。

始终保留密码重置请求的详细审核记录(如 IP 地址或浏览器指纹)。

您不应该将身份或凭据管理和验证委托给第三方提供商(如谷歌、推特、脸书或微软)，即使初始集成看起来很有吸引力(容易)。外包这些安全基础设施的关键支柱可能会在以后引起问题。

## 严格的运输安全(STS)

安全的网络应用程序(或它们的任何部分或片段)永远不应该通过 HTTP 加载(TLS 应该是强制性的)。不幸的是，“我们只说 HTTPS 语”的方法存在很大的可用性问题。公众习惯于忽略 URI 模式，避免明确指定协议。它是“facebook.com”和“google.com”，而不是“https://www.facebook.com”和“https://www.google.com”。由于很少指定模式或协议，因此“默认”协议选择被委托给用户代理。不幸的是，大部分(全部？)用户代理默认使用“HTTP”而不是“HTTPS”作为默认模式。不支持 HTTP 会提高安全性，但也会让很多用户无法访问 web 应用程序。

大多数网络应用程序选择通过超文本传输协议进行响应，以最大限度地减少可用性问题。基于 HTTP 的响应没有内容，而是将 HTTP-301(永久重定向)返回到与 HTTPS 对等的 URL。响应 HTTP 请求提高了可用性，但使用户面临最终陷入敌对或不可信网络环境的风险，这种环境可能会恶意拦截和修改 HTTP 响应，从而危及用户会话。

**严格传输安全(STS)** 是一种机制，用于在(最终)通过敌对或不可信网络访问响应 HTTP 的 web 应用程序时，将偶然用户受到攻击的可能性降至最低。STS 在 HTTP 和 HTTPS 响应中添加了一个`Strict-Transport-Security`头，它指定了用户代理只能通过 HTTPS 访问服务器的时间段。符合 STS 的用户代理应该记住 STS 指令和持续时间(`max-age`)来执行它。强制执行的 STS 会导致用户代理在发出任何 HTTP 请求之前自动将其转换为等效的 HTTPS 请求。这种自动的客户端 HTTPS 转换将使偶然进入流氓网络环境的用户免于收到恶意的 HTTP 内容。但是，对于那些以前从未访问过响应 HTTP 的 web 应用程序的用户代理，并且用户代理事先没有记录强制的 STS 条目，STS 不会提供任何保护。

一个免费的 STS 机制是 STS [预加载](https://hstspreload.appspot.com/)，这是一种提交说 HTTPS 语的域供用户代理包含为仅限 HTTPS 的方式。您可以在这里查看 Chrome 浏览器[预装 STS 参与者的完整列表。](https://www.chromium.org/hsts)

使用 STS 实际上没有缺点，它是一种低成本、高影响的预防性安全机制。添加一年 STS 实施的 IIS 配置(`web.config`)是:

代码清单 24

```cs
  <system.webServer>
  ...
    <httpProtocol>
      <customHeaders>
        <add
  name="Strict-Transport-Security" value="max-age=31536000;
          includeSubDomains; preload "/>
      </customHeaders>
    </httpProtocol>
  ...
  </system.webServer>

```

并非所有的用户代理都支持 STS，所以显式的 HTTP-301 重定向可能仍然有用。

## X 帧选项(XFO)

[点击劫持](https://en.wikipedia.org/wiki/Clickjacking)是一种常见的攻击技术，在这种技术中，用户被诱骗无意中执行了一个用户从未打算执行的不需要或未经批准的操作。Clickjack 受害者通常被诱骗点击来自另一个 web 应用程序的某些 UI 元素，该应用程序呈现在用户认为正在点击的内容的透明层上。这个技巧通常是通过利用`<frame>`或`<iframe>` HTML 标签来实现的。

`X-Frame-Options` ( [XFO](https://tools.ietf.org/html/rfc7034) )标题指示兼容浏览器对将 XFO 标记的内容加载到`<frame>`和`<iframe>`标签中施加某些防御限制。XFO 值有三种设置:

*   `DENY`
*   `SAMEORIGIN`
*   `ALLOW-FROM uri`

`DENY`防止 XFO 标记的资源被陷害。`SAMEORIGIN`允许 XFO 标记的内容仅从与 XFO 标记的内容相同的来源构建。`ALLOW-FROM`允许 XFO 标记的内容仅从`uri`指定的来源进行构建。

设置 XFO 的 IIS 配置示例如下:

代码清单 25

```cs
  <system.webServer>
  ...

  <httpProtocol>

  <customHeaders>

  <add name="X-Frame-Options" value="SAMEORIGIN" />

  </customHeaders>

  </httpProtocol>
  ...
  </system.webServer>

```

大多数浏览器都不支持`ALLOW-FROM` XFO 设置，但是`DENY`和`SAMEORIGIN`得到了广泛支持。

## 内容-安全-策略(CSP)

`Content-Security-Policy`报头( [CSP](http://content-security-policy.com/) ，不要与前面章节中的加密服务提供商混淆)是 XFO 更强大的替代品，具有更丰富的防御功能。虽然 XFO 在现代浏览器中有不错的支持，但它作为一个标准被否决了，并且被 CSP 的`frame-ancestors`指令废弃了。

CSP 是一个非常强大的策略设置机制，但是需要仔细的策略配置、测试和调整才能有效。非琐碎的 CSP 策略也往往相当冗长，并在网络上浪费大量字节，增加了响应膨胀。一个简单的 CSP 策略可能是:

代码清单 26

```cs
  Content-Security-Policy: default-src
  'self'

```

此策略强制仅从文档本身的来源加载所有内容。设置 CSP 的 IIS 配置示例如下:

代码清单 27

```cs
  <system.webServer>
  ...

  <httpProtocol>

  <customHeaders>

  <add name="Content-Security-Policy" value="default-src
  'self';" />

  </customHeaders>

  </httpProtocol>
  ...
  </system.webServer>

```

## 子资源完整性

大多数重要的 web 应用程序都是由资源(图像、脚本、样式表、字体等)组装而成的。)从多个[原点](https://en.wikipedia.org/wiki/Same-origin_policy#Origin_determination_rules)加载。因此，全面的 web 应用程序安全性也需要所有这些来源的真实性保证，其中大部分都在您的控制范围之外。如果没有真实性保证，您不仅面临这些外部来源被黑客攻击和合法资源被恶意替换的风险，还可能遭受替换这些来源的 IP 地址的 DNS 中毒攻击，这可能是比直接黑客攻击服务器更容易的攻击。

TLS (HTTPS)连接、严格传输安全(T0)STS(T1)和公钥锁定(T2)HPKP(T3)机制都在全面的网络安全中发挥着重要作用。但是，他们专注于验证服务器，而不是内容。子资源完整性( [SRI](https://en.wikipedia.org/wiki/Subresource_Integrity) )是一种相对较新的机制，它允许网络应用程序也可以锁定内容(通过验证其真实性)。

代码清单 28

```cs
  <script

  src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"
  integrity="sha384-mXQoED/lFIuocc//nss8aJOIrz7X7XruhR6bO+sGceiSyMELoVdZkN7F0oYwcFH+"
    crossorigin="anonymous">
  </script>

```

`<script>`标签上的`integrity`属性包含从`src`属性加载的二进制有效载荷的`SHA384`散列。支持 SRI 的用户代理(例如浏览器)将拒绝加载任何哈希匹配失败的资源。计算资源的 SRI 散列的一种方法如下:

代码清单 29

```cs
  using (var
  http = new HttpClient())
  using (var
  dataStream = await http.GetStreamAsync(

  "https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"))
  using (var
  hash = SecurityDriven.Inferno.Hash.HashFactories.SHA384())
  {
        byte[]
  hashBytes = hash.ComputeHash(dataStream);
        string
  hash_b64 = Convert.ToBase64String(hashBytes);
        $"sha384-{hash_b64}".Dump();
  }

  // result:
  // sha384-mXQoED/lFIuocc//nss8aJOIrz7X7XruhR6bO+sGceiSyMELoVdZkN7F0oYwcFH+

```

或者，您可以在[srihash.org](https://www.srihash.org/)使用方便且不受信任的在线生成器。

## JSON 对象签名和加密(JOSE)框架

JOSE 是一套相关的规范，用于加密和签名内容，并使其可移植和在网络上传输。JOSE 有许多活动部件，即:

*   JSON 网络签名(JWS)–[RFC 7515](https://tools.ietf.org/html/rfc7515)
*   JSON web encryption(jwe)——[RFC 7516](https://tools.ietf.org/html/rfc7516)
*   JSON web key(jwk)——[RFC 7517](https://tools.ietf.org/html/rfc7517)
*   JSON 网络算法(JWA)–[RFC 7518](https://tools.ietf.org/html/rfc7518)
*   JSON Web 令牌(jwt)——[RFC 7519](https://tools.ietf.org/html/rfc7519)
*   包含示例的 JOSE 烹饪书–[RFC 7520](https://tools.ietf.org/html/rfc7520)

其中一位 JOSE 合著者(他是微软标准架构师)将其描述为*“4.5 年的旅程，旨在创建简单的基于 JSON 的安全令牌格式和底层的基于 JSON 的加密标准，目标是让事情变得简单。”*

虽然 JOSE 规范可能确实比其他一些微软支持的标准更简单，比如 SAML 2.0(由同一个微软架构师合著)，但它们远不简单(正如 5+RFC 所建议的那样)，并且在规范复杂性方面更接近于 TLS RFCs。TLS 和 JOSE 之间的相似之处也可以从各种 JOSE 组件的大量可能组合中看出，其中一些可能是安全的，JOSE 烹饪书指出*“整套排列非常大，可能会让一些人望而生畏。”*这并不是旨在“保持简单”的良好安全规范应该如何开始。

继续我们的 TLS 类比，我们可以在传输层保护数据(这是 TLS 所做的)和应用层保护数据的类似尝试(这是 JOSE 试图通过 JSON 做的)之间进行类比。

高质量的 TLS 库很少，除非你是一个大型浏览器制造商或浏览器支持者，或者拥有亚马逊或 CloudFlare 规模，否则编写 TLS 库不应该在你的议程上。同样，尽管 JOSE 声称的目标是保持简单，定制 JOSE 实现可能充满安全漏洞。JOSE 是在 2015 年标准化的，所以对于任何特定的实现来说，它仍然太新，无法经受时间的考验(这是安全规范的关键测试之一)。

如果您正在考虑使用 JOSE 的某些部分，请记住以下几点:

*   JOSE 大量使用 JSON 序列化和反序列化。NET)是 CPU 昂贵、内存昂贵和 GC 昂贵的。
*   JOSE 不能有效地编码二进制数据或任何其他非字符串数据，并且不必要地浪费大量存储、内存和网络字节。
*   JOSE (JSON)不支持对单个字段的惰性的、及时的访问——必须首先对整个 JSON 结构进行反序列化。
*   JOSE 加密(JWE)是可选的(另一个缺点)，通常不使用。JWT(令牌)通常是签名的，但不是加密的。
*   JWE 对称加密模式仅限于 AES-CBC(例如，不错的保守选择，但不如 CTR)。媒体访问控制标签至少有 32 字节长(过度使用会浪费存储空间)。
*   JOSE 以算法敏捷性的名义遵循“点菜”方法。我们知道同样的“点菜”方法对 TLS 的效果有多好，因为 TLS 是漏洞的一个持续来源。TLS 1.3 工作组最终将 1.3 规范细化和收紧，以使用更少的只支持行政审批的方案，而不会破坏以前版本的所有“功能”。JOSE 的算法灵活性已经造成了安全漏洞。

## 饼干

有些人错误地认为基于 HTTP cookie 的身份验证等同于服务器端状态，其中 cookie 只包含会话 ID，所有会话信息都基于该 ID 并存储在服务器端。然而，`Cookie`(请求)和`Set-Cookie`(响应)头只是特定的 HTTP 头，并不强制任何特定的认证机制或方法。Cookies 实际上是在[RFC 6265](https://tools.ietf.org/html/rfc6265)–“HTTP 状态管理机制”中描述的，该机制声明:

Cookie 头包含用户代理在以前的设置 Cookie 头中收到的 Cookie。源服务器可以忽略 Cookie 头或将其内容用于应用程序定义的目的。

正是这种“应用程序定义的目的”使 cookie 机制如此有用，cookie 的魔力使其不同于任何其他 HTTP 头，它具有以下功能:

使用 Set-Cookie 头，服务器可以在 HTTP 响应中向用户代理发送一个短字符串，用户代理将在 Cookie 范围内的未来 HTTP 请求中返回该短字符串。

这种将一些数据或状态从服务器发送到客户端，并让客户端的用户代理(浏览器)在所有后续请求中自动、透明地将该数据或状态发送回服务器的能力是实现客户端状态(从服务器的角度来看是无状态的)的一种很好的方式。

另一个优秀的 cookie 功能是`HttpOnly`属性，它指示用户代理禁止通过任何非 HTTP API(特别是 JavaScript)访问 cookie。我们可以使用 JavaScript APIs 来读取每个 HTTP 头——除了`HttpOnly`标记的 cookie 头。大多数其他的网络防御在跨站点脚本(XSS)或 JavaScript 注入攻击下崩溃，但不包括`HttpOnly`cookie，后者可能会被削弱(因为在 XSS 统治下许多其他攻击将成为可能)，但不会允许 cookie(通常包含用户的认证身份)被劫持。

XSS 攻击是现代网络(大量用户贡献的内容)的祸根，而`HttpOnly`cookie 是一种向客户端卸载状态而不承担后果的好方法。XSS 袭击通常不是“如果”的问题，而是“何时”的问题。如果您在客户端存储带有身份的令牌，并且使用除`HttpOnly`cookie 之外的一些客户端存储(例如，HTML5 本地/会话存储，或者没有`HttpOnly`的 cookie)，那么您实际上是在将您的“城堡密钥”放在城堡墙之外——您真的有那么自信吗？

## HTTP/2

[HTTP/2](http://http2.github.io/) (RFC 7540)是 HTTP/1.1 协议的下一个版本。HTTP/1.0 于 1996 年发布，随后是 1999 年的 HTTP/1.1，2015 年的 HTTP/2——16 年后。HTTP/2 是一个主要的修订版，与 HTTP/1.1 有很大的不同。其中一些差异是:

表 11: HTTP/1.1 与 HTTP/2

| HTTP/1.1 | HTTP/2 |
| --- | --- |
| 每个请求一个连接(浏览器每个源汇集 6-8 个连接) | 每个原点一个连接 |
| 文本，例如“`GET /index.html HTTP/1.1`” | 二进制(即字节效率更高) |
| 有序和阻塞(请求-响应) | 完全多路复用(如 TCP/IP) |
| 每个请求都会重复标题 | 报头被压缩( [HPACK](http://httpwg.org/specs/rfc7541.html) 方法) |
| 加密是可选的(HTTP 与 HTTPS) | 加密是强制性的(某种程度上) |
| 仅客户端拉取(明确的 URI 请求) | 服务器推送(主动向客户端发送数据) |

HTTP/2 规范并没有强制要求加密，但是目前所有支持 HTTP/2 的浏览器只会用 TLS 建立 HTTP/2，这使得 HTTP/2 实际上强制要求加密。另一个重要的 HTTP/2 安全进步是 HTTP/2 实现必须使用 TLS 1.2 或更高版本。因此，使用 HTTP/2 会自动避免损坏或易受攻击的旧 TLS 版本。HTTP/2 正在让网络变得更快更安全，所以采用 HTTP/2 应该在你的日程上。微软在 IIS 10.0 中支持 HTTP/2，是 [Windows Server 2016](https://en.wikipedia.org/wiki/Windows_Server_2016) OS 的一部分。要查看 HTTP/2 的运行情况，请访问[HTTP vs HTTPS 测试](http://www.httpvshttps.com/)和[阿卡玛演示](https://http2.akamai.com/demo)网站。****