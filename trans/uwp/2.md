当您第一次启动 Visual Studio 2015 并选择创建新项目时，您会注意到许多不同的类别。我们感兴趣的属于**窗口**类别。在这里，您可以找到以下子类别:

*   **通用**包含创建通用 Windows 平台应用程序所需的模板。
*   **Windows 8** 包含该平台每个早期版本的多个子类别，如 Windows 8.1、Windows Phone 8.1 或适用于 Windows Phone 8.0 和 8.1 的 Silverlight 应用程序。
*   **经典桌面**包含使用基于该标准的 Windows Forms 或 WPF 等技术创建经典桌面应用程序的模板。NET 框架。

这本书将只涵盖通用视窗平台应用程序，因此可以从**通用**部分的模板开始创建。如果您需要为以前的 Windows 或 Windows Phone 版本创建应用程序，您可以在 [*简洁地*系列中找到由我编写并由 Syncfusion 出版的不同书籍。](https://www.syncfusion.com/resources/techportal/ebooks)

## 代码隐藏

通用视窗平台应用程序放弃了旧的基于窗口的范例，转而使用基于页面的新范例，页面以分层方式组织。用户在启动应用程序时，会停留在主页上。之后，他可以移动到其他页面，这些页面包含不同的特定内容。例如，新闻应用程序可以在主页中显示最近的新闻列表。用户可以点击其中一个列表项并导航到详细页面，该页面将显示新闻的全文。此外，应用程序可以有更多的页面:一个用于视频，一个用于照片库，一个用于特定的新闻类别，等等。

应用程序中的所有页面都由两个不同的文件组成:

*   主要的一个，以**结尾。xaml** 扩展，包含页面的视觉布局，用一种叫做 xaml 的语言编写，这是一种 XML 方言。
*   代码隐藏以**xaml . cs**扩展结束，包含能够与用户界面交互并执行逻辑操作的代码。要在解决方案资源管理器中查看此文件，您必须单击 XAML 文件附近显示的小箭头。事实上，代码隐藏文件在树结构中显示为 XAML 文件的子文件。代码隐藏中使用的语言取决于您使用的投影。在本书涵盖的示例中，它将包含 C#代码，因此文件名以**结尾。cs** 分机。例如，如果您选择 VB.NET 作为开发语言，代码隐藏文件将被命名为 **xaml.vb** 。

无论您要使用什么样的模板，对于通用视窗平台应用程序来说，都有一些文件和文件夹是必不可少的，并且包含在每个项目中。让我们看看最重要的。

### 类

最初，您可能会认为这个文件代表一个应用程序页面。事实上，像任何其他页面一样，它由一个 XAML ( **App.xaml** )和一个代码隐藏文件( **App.xaml.cs)** 组成。`App`类是一个特殊的类，因为它是每个 UWP 应用的入口。它负责初始化应用程序正常工作所需的一切，比如初始化管理应用程序不同页面的 **`Frame`** 类，或者处理管理应用程序生命周期的所有入口点。

**`App`** 类的一个重要特性是，它的实例一直保持活动状态，直到应用程序关闭或暂停。当应用程序运行时，可以访问在此类中声明的每个属性，以便以后使用。这种行为的另一个后果是`App`类是注册所有资源(如样式和模板)的中心点，这些资源可以从应用程序页面中的控件中使用。我们将在本章后面详细介绍如何使用这个特性。

该文件夹通常包含所有视觉资源(图像、徽标、图标等)。)在应用程序中使用。这不是严格的要求；您可以将此类数据放在项目的任何其他文件夹中。但是，将所有内容都放在资产文件夹下是一个很好的做法。

在项目中，你会发现一个名为 **Package.appxmanifest** 的特殊文件。这是**清单文件**，它非常重要:它的目的是定义应用程序的所有主要特性，比如标准视觉资产(徽标、图块等)。)，元数据(名称、描述等))，功能，与操作系统的集成等。在引擎盖下，它是一个 XML 文件，但是 Visual Studio 提供了一个可视化编辑器，当您双击它时，它会自动加载。

清单由以下部分组成:

*   **应用程序:**本节描述了应用程序的所有基本元数据，如名称、默认语言、支持的方向和推送通知配置。
*   **视觉资产**:本节通过将所有用作商店徽标的默认图像定义为默认图块的背景或应用程序加载时显示的闪屏，来描述应用程序的视觉布局。由于 Windows 10 支持多种分辨率和屏幕尺寸，本部分将允许您为同一张图像上传不同的格式。在本系列的第二本书中，您将更好地理解 Windows 10 如何管理这种情况。
*   **功能** : 此部分用于设置应用程序正在使用哪些功能(硬件和软件)，如互联网连接、地理定位服务、访问图片库等。在这本书里，每次我们谈论一个需要启用特定功能的特性时，你都会发现一个特别的注释。
*   **声明**:本节用于扩展应用，使其能够与操作系统或其他应用进行深度交互。每次我们要使用一些扩展应用程序的代码时(比如在后台执行操作或共享内容)，我们都需要在这一部分设置入口点。我们将在后面讨论合同和后台执行时详细介绍这一部分。
*   **内容网址**:这一部分是专门针对一个名为**网络视图**的控件，它可以用来显示应用程序内部的网络内容(就像一个 HTML 页面)。这个控件通过拦截和调用特定的 JavaScript 函数，为开发人员提供了一种与页面交互的方式。此功能仅针对受信任的网站启用，这些网站的网址需要在此部分中添加。为了提高安全性，仅支持使用 HTTPS 协议的站点。
*   **打包**:这最后一节可以用来定制一些关于你将要在商店发布的包的信息，比如应用程序名、发布者名或者版本号。当您将应用程序与商店关联以发布它时，本节中详细介绍的许多信息都会自动设置。在这些电子书的最后你会发现更多的细节。

XAML 代表可扩展应用标记语言。它基于 XML，用于定义页面的视觉布局，类似于 HTML 用于定义网页布局的方式。

控件(如按钮或文本块)由一个 XML 标记标识，该标记按照层次结构插入到页面中。标签可以插入到其他标签中以定义关系。例如，这种方法被广泛用于定义页面的布局。有一些特殊的控件(我们将在第 3 章中详细介绍)充当其他控件的容器，因此，它们一个嵌套在另一个中。

以下是页面定义的样子:

代码清单 4

```
  <Page
      x:Class="Styles.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:Styles"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <Grid>
          <StackPanel>
              <TextBlock Text="Hello
  world" />
          </StackPanel>
      </Grid>
  </Page>

```

每个页面都继承自一个名为 **`Page`** 的基类，即起始节点。放置在其中的每隔一个标签将定义页面布局。你可以看到在页面定义中有一个属性叫做 **`x:Class`** :它定义了哪个是连接到页面的代码隐藏类。在示例中，它是一个名为 **`MainPage`** 的类，属于名为 **`Styles`** 的命名空间。

名称空间应该已经为开发人员所熟悉；这是一种通过为类定义逻辑路径来更好地组织代码的方法。这样(即使这不是建议的方法)，您也可以有两个同名的类，因为它们属于两个不同的名称空间。名称空间用点分隔。例如，如果您有一个名为 **`Person`** 的类属于 **`Entities`** 命名空间，它将由完整定义 **`Entities.Person`** 来表示。通常，作为默认行为，项目中的名称空间与文件夹映射。如果创建一个名为 **`Entities`** 的文件夹，并在其中创建一个新类，默认情况下，它将属于 **`Entities`** 命名空间。

XAML 的命名空间也是如此。XAML 控件最终是属于特定命名空间的标准类。当您想要在页面内使用控件时，必须确保在页面定义中添加了正确的命名空间。对于开发人员创建的自定义控件或包含在外部库中的第三方控件来说尤其如此。事实上，大多数原生控件(按钮、文本框等。)可以使用，而不必担心命名空间。

让我们看一个如何在 XAML 使用命名空间的例子，在我们的项目中包括**微软商店服务软件开发工具包**(可以在这里下载)一个外部库，它添加了一系列控件和应用编程接口来与商店提供的服务进行交互。这个库包括一个在你的应用中显示广告的控件，叫做`AdControl`。然而，由于它是外部库的一部分，并且没有嵌入到通用视窗平台中，我们需要在使用它之前声明它所属的命名空间。该控件包含在命名空间`Microsoft.Advertising.WinRT.UI`中；因此，您需要在 **`Page`** 定义中添加以下声明:

代码清单 5

```
  xmlns:ad="using:Microsoft.Advertising.WinRT.UI"

```

每个命名空间都以 **`xmlns`** 前缀(XML Namespace)开头，这总是必需的。然后，您需要为命名空间指定一个唯一的标识符，每当您需要访问一个控件或属于它的一个类(在前面的示例中，它是 **`ad`** )时，就会在页面内部使用该标识符。下面是在页面中显示广告控件的示例代码:

代码清单 6

```
  <ad:AdControl x:Name="MyAdControl" />

```

如您所见，我们已经为控件的名称添加了前缀( **`AdControl`** )我们之前分配给命名空间的标识符( **`ad`** )。

每个控件都可以通过两种方式进行自定义:定义属性和订阅事件。它们中的每一个都用控件的属性来标识，即使它们有两个不同的目的。

**属性**用于确定控件的外观和行为，它们只需为特定属性赋值即可设置。假设我们想通过使用名为`TextBlock`的控件在页面上显示文本。在这种情况下，我们需要更改名为`Text`的属性值，如下例所示:

代码清单 7

```
  <TextBlock Text="Hello world" />

```

但是，有一些属性不能像前面的示例那样用简单的字符串来表示。例如，如果要将图像定义为控件的背景，则需要使用扩展语法设置名为`Background`的属性，如下例所示:

代码清单 8

```
  <Grid>
      <Grid.Background>
          <ImageBrush ImageSource="/Assets/Background.png"
  />
      </Grid.Background>
  </Grid>

```

扩展语法用设置为控件子级的节点表示。前缀与控件的名称相同，后跟属性的名称，用点分隔。在示例中，由于我们需要设置名为`Grid`的控件的`Background`属性，因此我们使用表达式`Grid.Background`。

任何控件都有一个特殊属性叫做`x:Name`。它是一个字符串，在页面中唯一标识它(不能有两个同名的控件)。这一点尤其重要，因为它允许开发人员从代码后面访问控件。由于有了这个标识符，您将能够直接从代码中读取和设置属性。

例如，假设您有一个`TextBlock`控件，您通过以下方式为它分配一个唯一的标识符:

代码清单 9

```
  <TextBlock x:Name="MyText" />

```

在代码隐藏中，您只需使用`x:Name`属性的值就可以与控件进行交互。以下示例显示了如何在代码中更改`Text`属性:

代码清单 10

```
  MyText.Text = "Hello world!";

```

**事件，**另一方面**、**用于确定用户或应用程序如何与您的控件交互。每当发生涉及控件的事情时，都会引发一个事件，您将能够在代码隐藏中管理它。一个非常常见的事件是`Click`，它被所有提供与用户直接交互的控件所暴露，就像`Button`一样。每当用户按下按钮时(通过点击鼠标或轻击手指)，就会引发`Click`事件。您需要用一种称为**事件处理程序**的特定方法来管理它。Visual Studio 将帮助您以正确的方式定义此方法。编写要分配给事件的名称后，Visual Studio 将负责在代码中为您创建事件处理程序。

以下示例向您展示了如何为 XAML 的`Button`控件的`Click`事件定义事件处理程序:

代码清单 11

```
  <Button Click="button_Click" />

```

Visual Studio 将为您生成以下事件处理程序:

代码清单 12

```
  private void
  button_Click(object sender, RoutedEventArgs e)
  {
      MyText.Text
  = "Hello
  world!";
  }

```

如您所见，事件处理程序是常规方法，但有特定的定义。它们总是在签名中包含两个参数，作为开发人员，我们可以使用这两个参数来更好地处理事件。第一个参数叫做`sender`，它是对调用事件的对象的引用(在我们的示例中，它将包含对`Button`控件的引用)；相反，第二个参数提供了一些有助于理解事件上下文的属性。在接下来的章节中，我们将看到这个参数的更详细的示例用法。在事件处理程序中，您只需编写在事件引发时要执行的代码。在上一个示例中，我们在每次按下`Button`时设置`TextBlock`控件的`Text`属性。

Visual Studio 提供了一个名为 **IntelliSense** 的功能，它可以在您编写代码时自动完成代码，并动态提供一些关于属性和事件的有用信息。智能感知还提供了一个有用的视觉参考来区分属性和事件。前者通过小扳手识别，后者通过闪电图标识别。

![](../Images/image021.png)

图 21:用于突出显示属性和事件的不同图标。

如果你曾经使用过像 HTML 这样的网络技术，那么资源的概念对你来说将是熟悉的。就像在 HTML 世界中一样，您可以通过使用 CSS 语言在多个页面中共享和重用样式。资源可用于定义控件的样式和行为，并在应用程序的不同页面中重用它。

资源的定义得益于一个名为`Resources`的属性，它由任何控件提供。由于 XAML 基于分层结构，每个嵌套控件都能够使用其父控件定义的资源。例如，下面的示例演示如何定义网格控件和嵌套在其中的任何其他控件可用的一些资源:

代码清单 13

```
  <Grid>
      <Grid.Resources>
          <!-- insert your resources here
  -->
      </Grid.Resources>
  </Grid>

```

然而，资源通常被定义为两个不同的范围:页面范围和应用程序范围。

由于`Page`类提供的`Resources`属性，页面资源是在页面本身中定义的。这样，页面中包含的所有控件都将能够访问资源。以下是页面资源定义的示例:

代码清单 14

```
  <Page
      x:Class="Styles.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:Styles"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <Page.Resources>
          <!-- insert here your resources
  -->
      </Page.Resources>
  </Page>

```

相反，应用程序资源是使用 **App.xaml** 文件中定义的`Application`类的`Resources`属性来定义的。这样，应用程序的任何页面或用户控件中的任何控件都可以使用这些资源。下面是一个示例定义:

代码清单 15

```
  <Application
      x:Class="Styles.MainPage "

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:Styles">

      <Application.Resources>
          <!-- insert your resources here
  -->
      </Application.Resources>

  </Application>

```

就像控件由`x:Name`属性唯一标识一样，资源由`x:Key`属性标识。要将资源应用于控件的属性，需要使用一种称为**标记扩展**的特殊 XAML 语法。这是一种直接在 XAML 描述复杂操作的方式，否则，需要用代码编写一些逻辑。XAML 有许多标记扩展，我们将在本章中讨论其中的一些。

用于将资源应用于控件的称为`StaticResource`。例如，下面是如何使用它将样式应用于`TextBlock`控件:

代码清单 16

```
  <TextBlock Style="{StaticResource CustomStyle}"
  />

```

通过在大括号中包含`StaticResource`关键字来应用资源，后跟资源的名称(这是分配给`x:Key`属性的值)。

在某些情况下，尤其是如果您有很多资源，页面或应用程序的定义可能会变得过于拥挤和难以阅读。XAML 通过在一个专用文件中声明资源，为您提供了一种更好地管理资源的方法，同样，您可以在另一个 HTML 文件中定义 CSS 样式，而不仅仅是内联。

在 XAML，这些外部文件被称为**资源字典**。Visual Studio 提供了一个特定的模板来创建这样的文件:只需在解决方案资源管理器中右键单击您的项目，然后选择**添加- >新项目**。您会发现一个名为**资源字典**的文件类型是可用的模板之一。它将自动创建一个具有以下定义的文件:

代码清单 17

```
  <ResourceDictionary

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

       <!-- here you can place all your
  resources -->

  </ResourceDictionary>

```

使用这个文件很容易。您只需将所有资源包含在 **`ResourceDictionary`** 标签中，就像您将它们添加为页面或应用程序资源一样。然后，您需要在主应用程序中包含资源字典文件，方法是在 App.xaml 文件中声明它，如下所示:

代码清单 18

```
  <Application.Resources>
      <ResourceDictionary>
          <ResourceDictionary.MergedDictionaries>
              <ResourceDictionary Source="Resources/Styles.xaml" />
          </ResourceDictionary.MergedDictionaries>
      </ResourceDictionary>
  </Application.Resources>

```

资源字典文件被添加到由`ResourceDictionary`类提供的`MergedDictionaries`属性中。在前面的示例中，您可以看到我们只添加了一个文件，但是您可以添加任意多的文件(例如，如果您想要根据资源的类型或用例将资源拆分到不同的文件中)。

现在让我们详细看看 XAML 框架为开发人员提供了哪种资源。

**款式**

XAML 的风格类似于 CSS 风格。它们的目的是在一种样式中收集多个属性定义，以便所有属性在应用于控件时自动更改。这样，如果您改变主意，想要编辑其中一个属性，您可以只在一个地方(样式定义)进行编辑，而不是手动编辑所有控件。

风格是这样的:

代码清单 19

```
  <Style TargetType="TextBlock" x:Key="RedStyle">
      <Setter Property="Foreground" Value="Red" />
      <Setter Property="FontSize" Value="30" />
  </Style>

```

样式由`Style`控件标识，除了我们已经了解的 **`x:Key`** 属性之外，该属性还提供了一个名为`TargetType`的属性，用于指定该样式可以应用于哪种控件。在`Style`控件中，您可以放置任意数量的`Setter`标签。它们中的每一个都可以改变特定属性(由`Property`属性定义)的值(使用`Value`属性)。

在前面的示例中，我们已经定义了一个样式，该样式可以仅应用于`TextBlock`控件，并更改其两个属性:颜色(`Foreground`)和文本大小(`FontSize`)。

样式提供了一种方法，不仅可以将它们应用于特定的控件，还可以应用于任何类型与我们在`TargetType`属性中定义的类型相匹配的控件。这样，您将不必使用`StaticResource`属性手动应用样式，因为它将被自动应用。这些样式被称为`implicit styles`，它们通过省略`x:Key`属性来定义，如下例所示:

代码清单 20

```
  <Style TargetType="TextBlock">
      <Setter Property="Foreground" Value="Red" />
      <Setter Property="FontSize" Value="30" />
  </Style>

```

这样，所有`TextBlock`控件将自动使用更大的红色字体显示文本。隐式样式基于定义它们的范围来应用。如果它们已在页面中声明，它们将自动应用于页面中的所有控件；否则，如果它们已经被声明为应用程序资源，它们将被应用于所有页面中的所有控件。

记住 XAML 的等级制度很重要。说到风格，这意味着内在风格总是战胜外在风格。例如，如果您已经在应用程序级别定义了一种样式，将所有`TextBlock`的字体颜色更改为红色，但随后又在页面级别定义了另一种样式，将颜色更改为蓝色，则第一页将优先于应用程序。

**数据模板**

数据模板是特殊的资源，可以应用于一些控件来定义可视化布局。它们经常与用于显示项目集合的控件结合使用，如`ListView`或`GridView`(我们将在第 3 章中讨论它们)。

数据模板只包含用于渲染列表中每个项目的 XAML。这样，XAML 将自动重复并应用于列表的每个元素。假设您想要显示一个人员列表，以下是用于此目的的数据模板:

代码清单 21

```
  <DataTemplate x:Key="PeopleTemplate">
      <StackPanel>
          <TextBlock Text="Name"
  />
          <TextBlock Text="{Binding Path=Name}" />
          <TextBlock Text="Surname"
  />
          <TextBlock Text="{Binding Path=Surname}" />
      </StackPanel>
  </DataTemplate>

```

目前，只需忽略 **`Binding`** 关键词。这是一个新的标记扩展，将在本章后面详细介绍。目前，重要的是要知道，通过这个数据模板，您将能够显示集合中每个人的姓名。

数据模板的行为类似于任何其他资源。它们可以在控件内内联定义为页面或应用程序资源，也可以在资源字典中定义。然后，您可以使用 **`StaticResource`** 关键字应用它们。通常，当您处理显示集合的控件时，数据模板被分配给一个名为 **`ItemTemplate`** 的属性，该属性定义了用于集合中每个项目的模板，如下例所示:

代码清单 22

```
  <ListView ItemTemplate="{StaticResource PeopleTemplate}" />

```

**刷子**

画笔是 XAML 元素，用于定义控件的填充方式。例如，当你设置一个 **`Button`** 控件的背景颜色时，你使用的是画笔。画笔有很多种:最简单的叫做 **`SolidColorBrush`** ，用来表现一种颜色。大多数情况下，您可以使用标准属性的语法来应用这个画笔。将颜色的名称分配给所需的属性就足够了，因为 XAML 运行时会在引擎盖下为您创建一个`SolidColorBrush`。例如，下面是如何创建一个红色背景的 **`Rectangle`** 形状:

代码清单 23

```
  <Rectangle Width="200" Height="200" Fill="Red" />

```

然而，也有更复杂的画笔只能用扩展的语法来表达。例如，您可以通过使用 **`LinearGradientBrush`** 或 **`RadialGradiantBrush`** 来应用渐变而不是简单的颜色。它们都有相同的目的，但是第一个使用一条线作为颜色之间的分隔符，第二个应用了圆形效果。

以下是如何将渐变画笔应用到我们之前看到的相同的 **`Rectangle`** 控件:

代码清单 24

```
  <Rectangle Width="200" Height="200">
      <Rectangle.Fill>
          <LinearGradientBrush>
              <GradientStop Color="Blue" Offset="0" />
              <GradientStop Color="Red" Offset="1" />
          </LinearGradientBrush>
      </Rectangle.Fill>
  </Rectangle>

```

在渐变画笔内部，我们可以插入多个 **`GradientStop`** 控件。它们中的每一个都定义了将要应用的颜色之一，您可以使用 **`Offset`** 属性指定渐变停止的位置。或者，您也可以将两个属性应用于名为 **`StartPoint`** 和 **`EndPoint`** 的`LinearGradientBrush`，以定义渐变应该开始和结束的点的坐标。

最后，您还可以通过使用 **`ImageBrush`** 控件将图像应用为画笔，这也需要扩展语法，如下例所示:

代码清单 25

```
  <Rectangle Width="200" Height="200">
      <Rectangle.Fill>
          <ImageBrush ImageSource="background.png"
  />
      </Rectangle.Fill>
  </Rectangle>

```

**根据主题处理资源**

到目前为止，我们只看到了一种将资源应用于控件的方法:使用 **`StaticResource`** 关键字。然而，通用视窗平台提供了另一个名为 **`ThemeResource`** 的标记扩展，可以用来根据设备的主题自动调整资源。

让我们后退一步，详细看看这个特性是如何工作的。Windows 10 支持主题的概念，主题是一组全局应用于整个操作系统的资源。有些主题只是为了满足用户的视觉偏好，比如**深色主题**(深色背景上的白色文本)和**白色主题**(白色背景上的深色文本)。相反，其他一些产品为视觉障碍者提供了更好的用户体验，比如**高对比度**产品。

在设计应用程序时，开发人员需要记住这个特性。否则，就有这样的风险:它只适合其中一个主题，而不适合其他主题。假设您在页面中有一个 **`TextBlock`** 控件，并且您强制文本的颜色为白色:如果用户在他们的设备上应用了白色主题，他们将无法阅读文本。感谢 **`ThemeResource`** 关键词，你可以定义多个同名资源。系统将自动应用最适合当前主题的一个。

下面是示例代码:

代码清单 26

```
  <Application.Resources>
      <ResourceDictionary>
          <ResourceDictionary.ThemeDictionaries>
              <ResourceDictionary x:Key="Dark">
                  <SolidColorBrush Color="Red" x:Key="ApplicationTitle" />
              </ResourceDictionary>
              <ResourceDictionary x:Key="Light">
                  <SolidColorBrush Color="Blue" x:Key="ApplicationTitle" />
              </ResourceDictionary>
          </ResourceDictionary.ThemeDictionaries>
      </ResourceDictionary>
  </Application.Resources>

```

如您所见，我们已经定义了(作为应用程序资源)两个同名的资源。它们都是 **`SolidColorBrush`** 物品，并且它们具有相同的 **`x:Key`** 值、 **`ApplicationTitle`** 。然而，这两把刷子有不同的价值。第一个设置颜色为 **`Red`** ，第二个设置颜色为 **`Blue`** 。

他们两个都被加进了一个 **`ResourceDictionary`** 属性里面叫做 **`ThemeDictionaries`** 。一个重要的区别是，每个 **`ResourceDictionary`** 都有一个唯一的标识符，分配有 **`x:Key`** 属性。这个标识符通过使用特定的命名约定告诉系统资源指的是哪个主题:

*   **`Default`** ，应用为默认主题。
*   **`Dark`** ，使用黑暗主题时应用。
*   **`Light`** ，使用灯光主题时应用。
*   **`HighContrast`** ，使用高对比度主题时应用。

现在你只需要像以前一样应用你的资源，但是使用 **`ThemeResource`** 标记扩展代替 **`StaticResource`** 扩展。下面是示例代码，显示了如何将先前的样式应用于 **`TextBlock`** 控件:

代码清单 27

```
  <TextBlock Text="Title" Foreground="{ThemeResource ApplicationTitle}" />

```

这个标记扩展最有用的优点之一是它能够在运行时检测主题的变化。这样，如果用户在应用程序运行时更改主题，所有资源都将自动适应，而无需重新启动。

您也可以通过将 **`RequestedTheme`** 属性应用于整个应用程序(在 **App.xaml** 文件中)或单个页面或控件来强制应用程序的主题。这样，资源将忽略用户的主题，只遵循强制主题定义的规则。以下示例显示了如何强制整个应用程序使用 **`Dark`** 主题:

代码清单 28

```
  <Application
      x:Class="Qwertee.App"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:Qwertee"
      RequestedTheme="Dark">

  </Application>

```

#### 动画片

动画可能是 XAML 最强大的资源之一。只需几行 XAML 代码，您就可以制作页面中几乎任何控件的动画。例如，您可以使控件消失，移动到另一个位置，或者更改大小，等等。

使用名为`Storyboard`的控件渲染动画，该控件提供不同类型的动画:

*   当您想要通过更改数字属性(如`FontSize`)来激活控件时，使用`DoubleAnimation`。
*   当您想要通过更改颜色属性来激活控件时，使用`ColorAnimation`。
*   当您想要通过更改控件的坐标来设置控件的动画时，使用`PointAnimation`。

在详细了解动画如何工作之前，让我们先来看看定义`DoubleAnimation`的示例代码:

代码清单 29

```
  <Storyboard x:Name="Animation">
      <DoubleAnimation Storyboard.TargetName="MyShape"
                       Storyboard.TargetProperty="Opacity"
                       From="1.0"
                       To="0.0"
                       Duration="0:0:5" />
  </Storyboard>

```

请满足另一个 XAML 概念，称为**附加属性。**它们是从一个控件继承的特殊属性，但可以应用于其他控件。在这种情况下，`TargetName`和`TargetProperty`是两个附加属性。它们被`Storyboard`控制暴露，但是它们被应用于`DoubleAnimation`控制。它们的目的是定义动画将被应用的位置。`TargetName`定义控件的名称，而`TargetProperty`定义其值将在动画期间改变的属性的名称。

在前面的示例中，我们更改了由名称`MyShape`标识的控件的`Opacity`属性。其他三个属性定义动画的行为。`From`和`To`用于定义属性的开始和结束值，而`Duration`用于表示动画的长度。在本例中，我们将控件的 `Opacity`值从 1.0 更改为 0.0。动画将持续 5 秒。结果将是，5 秒钟后，控件将消失。

使用前面的代码，动画按照指定的长度平均分布。但是，XAML 也提供了一种方法，通过使用以后缀`UsingKeyFrames`结尾的控件来改变这种行为。以下示例显示了定义`DoubleAnimation`的另一种方法:

代码清单 30

```
  <Storyboard x:Name="Animation">
      <DoubleAnimationUsingKeyFrames Storyboard.TargetName="MyShape"

  Storyboard.TargetProperty="Opacity"

       Duration="0:0:10">
          <LinearDoubleKeyFrame KeyTime="0:0:3" Value="0.8"
  />
          <LinearDoubleKeyFrame KeyTime="0:0:8" Value="0.5"
  />
          <LinearDoubleKeyFrame KeyTime="0:0:10" Value="0"
  />
      </DoubleAnimationUsingKeyFrames>
  </Storyboard>

```

我们正在使用另一种版本的控制，叫做`DoubleAnimationUsingKeyFrames`。不同的是，这一次，我们使用`LinearDoubleKeyFrame`控件及其`KeyTime`和`Value`属性来精确指定动画计时。在示例中，结果是相同的(控件在 10 秒后消失)，但计时不同。3 秒后，`Opacity`属性将设置为 0.8，8 秒后设置为 0.5，10 秒后设置为 0，使控件消失。

轻松动画

对于用户来说，有些动画很好看，但是很难实现。假设你在页面上有一个形状，你想模拟它向屏幕底部下落。当形状接触底部边缘时，它应该会反弹，就像一个球一样。这种动画可能很难定义，因为它需要考虑物理定律，比如加速度和重力。

XAML 框架提供了内置动画，称为**放松动画**，可以用来实现这样的行为，而无需处理它们背后的所有复杂性。让我们看看如何使用以下动画之一来实现跳跃示例:

代码清单 31

```
  <Storyboard x:Name="EasingAnimation">
      <PointAnimation From="0,0" To="0, 200" Duration="0:0:3"
                      Storyboard.TargetName="Circle"
                      Storyboard.TargetProperty="Center">
          <PointAnimation.EasingFunction>
              <BounceEase Bounces="2" EasingMode="EaseOut" />
          </PointAnimation.EasingFunction>
      </PointAnimation>
  </Storyboard>

```

在这种情况下，除了以常规方式定义动画(在本示例中，是`PointAnimation`将形状从屏幕的一个位置移动到另一个位置)，我们使用许多可用的内置缓和动画之一来设置`EasingFunction`属性。在前面的示例中，我们使用了一个`BounceEase`控件，它可以用来给控件添加反弹效果。每个放松动画都提供了一组特定的属性来自定义它。例如，`BounceEase`提供了一个名为`Bounces`的属性来定义控件在动画结束时应该执行多少次反弹。

您可以在 [MSDN 文档](https://msdn.microsoft.com/en-us/library/ee308751(v=vs.110).aspx)中看到所有可用放松功能的列表。

系统动画

通用视窗平台提供了一套内置的动画，涵盖了许多常见的场景(如淡入或淡出效果)。你可以通过`ThemeAnimation`后缀来识别它们。使用它们很简单:您只需在`Storyboard`标签中添加控件。在前面的示例中，我们已经看到了如何通过将`Opacity`属性从 1 更改为 0 来手动对控件应用淡出效果。我们可以使用名为`FadeOutThemeAnimation`的内置动画获得相同的结果，如下例所示:

代码清单 32

```
  <Storyboard x:Name="Fade" TargetName="MyShape">
      <FadeOutThemeAnimation />
  </Storyboard>

```

您可以在这里看到所有可用系统动画的列表。

控制动画

动画被定义为资源，就像我们看到的样式和数据模板一样。唯一的区别是，我们需要使用`x:Name`属性来识别它们，而不是使用`x:Key`属性，就像我们使用常规控件一样。以下是定义为页面资源的动画示例:

代码清单 33

```
  <Page
      x:Class="BLEConnection.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <Page.Resources>
          <Storyboard x:Name="Animation">
              <DoubleAnimation Storyboard.TargetName="MyShape"
                       Storyboard.TargetProperty="Opacity"
                       From="1.0"
                       To="0.0"
                       Duration="0:0:5" />
          </Storyboard>
      </Page.Resources>

  </Page>

```

由于唯一的标识符，我们可以用与放置在页面中的控件交互的相同方式来控制代码中的动画。`Storyboard`控件提供了一些播放、停止或恢复动画的方法。以下示例显示了两个事件处理程序，通过两个按钮连接到`Click`事件，用于启动(使用`Begin()`方法)和停止(使用`Stop()`方法)动画:

代码清单 34

```
  private void
  OnStartClicked(object sender, RoutedEventArgs e)
  {
      Animation.Begin();
  }
  private void
  OnStopClicked(object sender, RoutedEventArgs e)
  {
      Animation.Stop();
  }

```

转场与动画没有很大的不同，但是它们不是可以在任何时候执行的，而是只在特定事件发生时执行，例如加载页面或删除集合中的元素。通用视窗平台为过渡提供本地支持。我们不需要手动定义动画，只需要使用任何控件提供的`Transitions`属性来定义使用哪个动画。与动画不同，我们不需要设置`Storyboard`，因为我们不控制执行。

以下是过渡用法的示例:

代码清单 35

```
  <Button Content="Transition test">
      <Button.Transitions>
          <TransitionCollection>
              <EntranceThemeTransition />
          </TransitionCollection>
      </Button.Transitions>
  </Button>

```

`Transitions`属性接受一个`TransitionCollection`元素。它的目的是在您想要管理多个事件的情况下支持多个过渡效果(例如，您想要应用入口和出口过渡)。在这个示例中，我们通过使用`EntranceThemeTransition`控件应用了一个入口效果。

像往常一样，因为我们使用的是 XAML，所以转换会传播到嵌套在控件中的每个元素。例如，如果我们将`EntranceThemeTransition`应用到一个`Grid`控件，那么放在它里面的所有其他控件都将继承入口动画。

另一个经常应用转换的场景是集合。例如，当页面被加载时，或者当一个项目被移除或添加到列表中时，您可以将动画应用到每个单独的项目。这个场景的实现方式与我们看到的标准控件相同。唯一的区别是，我们没有使用`Transitions`属性，而是使用了一个名为`ItemContainerTransitions`的属性，它被任何可以显示数据集合的控件所支持。分配给此属性的过渡将自动应用于列表中的每个项目。以下示例使用`ItemsControl`控件显示了这种行为:

代码清单 36

```
  <ItemsControl x:Name="People">
      <ItemsControl.ItemContainerTransitions>
          <TransitionCollection>
              <EntranceThemeTransition />
              <AddDeleteThemeTransition />
          </TransitionCollection>
      </ItemsControl.ItemContainerTransitions>
  </ItemsControl>

```

大多数高级控件为过渡提供内置支持。例如，上一个示例(在页面中删除、添加或显示项目时应用了过渡效果的项目集合)是由`GridView`或`ListView`等控件自动实现的，这将在下一章中介绍。

大多数 XAML 控件支持**视觉状态**的概念。一个控件可以呈现许多状态，并且每个状态都可以有不同的视觉表示。让我们以`Button`控件为例:默认情况下，它以浅灰色背景和黑色文本显示。如果您将鼠标移到按钮上，按钮将会有一个边框。或者，如果你按下它，它的状态会再次改变:背景变成深灰色。

可视化状态是一种定义不同状态的简单方法，无需为每个状态从头重写控件的布局。事实上，每个控件都有一个基本状态加上一组其他可视状态，这些可视状态是通过定义与原始状态的差异来表示的。在前面的示例中，`Button`的基础模板将包含控件的整个定义。相反，与“按下”状态相关的视觉状态将简单地改变原始模板的背景和文本颜色。

让我们通过向页面添加几个`TextBlock`控件来看一个例子:

代码清单 37

```
  <Grid>
      <StackPanel>
       <TextBlock Text="Text
  1" x:Name="FirstText"
  />
       <TextBlock Text="Text
  2" Visibility="Collapsed" x:Name="SecondText" />
       <Button Content="Change
  state" Click="OnChangeVisualStateClicked"
  />
      </StackPanel>
  </Grid>

```

您可以看到第一个`TextBlock`在页面加载时是可见的，而第二个是隐藏的，因为`Visibility`属性被设置为`Collapsed`。我们的目标是扭转这种情况，让第一个`TextBlock`消失，同时让第二个可见。以下是我们如何在不编写任何代码的情况下实现这一结果，只需使用 XAML 和视觉状态:

代码清单 38

```
  <Grid>
      <VisualStateManager.VisualStateGroups>
          <VisualStateGroup>
              <VisualState x:Name="Default" />
              <VisualState x:Name="ChangedState">
                  <Storyboard>
                      <ObjectAnimationUsingKeyFrames Storyboard.TargetName="FirstText"

  Storyboard.TargetProperty="Visibility">
                          <DiscreteObjectKeyFrame KeyTime="0" Value="Collapsed"
  />
                      </ObjectAnimationUsingKeyFrames>
                      <ObjectAnimationUsingKeyFrames Storyboard.TargetName="SecondText"

   Storyboard.TargetProperty="Visibility">
                          <DiscreteObjectKeyFrame KeyTime="0" Value="Visible"
  />
                      </ObjectAnimationUsingKeyFrames>
                  </Storyboard>
              </VisualState>
          </VisualStateGroup>
      </VisualStateManager.VisualStateGroups>
      <StackPanel>
          <TextBlock Text="Text
  1" x:Name="FirstText"
  />
          <TextBlock Text="Text
  2" Visibility="Collapsed" x:Name="SecondText" />
          <Button Content="Change
  state" Click="OnChangeVisualStateClicked"
  />
      </StackPanel>
  </Grid>

```

我们定义了一个`VisualStateManager`，它提供了一个名为`VisualStateGroup`的属性。在其中，我们可以定义想要在页面中管理的不同视觉状态。在这个示例中，我们创建了两个状态:一个叫做`Default`和一个`ChangedState`。第一个包含一个空定义。这是基本状态，它只是显示在页面中定义的控件。相反，第二个状态包含一个带有一组动画的`Storyboard`。第一个应用到第一个`TextBlock`并将`Visibility`属性更改为`Collapsed`以隐藏它。第二个应用到第二个`TextBlock`并将`Visibility`属性更改为`Visible`，以便显示。

一旦我们定义了视觉状态，我们就需要根据我们的需求来触发它们。一种方法是通过使用`VisualStateManager`类在代码隐藏中完成，如下例所示:

代码清单 39

```
  private void
  OnChangeVisualStateClicked(object
  sender, RoutedEventArgs e)
  {
      VisualStateManager.GoToState(this, "ChangedState", true);
  }

```

如果你还记得之前的 XAML 定义，我们已经插入了一个`Button`控件。当它被按下时，前一个事件处理程序被调用来触发视觉状态改变。这个目标是通过使用`VisualStateManager`类提供的`GoToState()`方法来实现的，该方法需要三个参数:将要更改其状态的控件(通常，它是在同一个页面中定义的，因此使用`this`关键字就足够了)、要应用的状态的名称以及一个`Boolean`参数，该参数告诉`VisualStateManager`在状态更改时是否应用动画。

我们刚才看到的是一个非常简单的例子，但是视觉状态非常有用，尤其是当您必须处理复杂的控件时。您可以使用 Visual Studio 设计器或 Blend(与 Visual Studio 一起安装的 XAML 设计器工具)随时重新定义控件的视觉状态。右击它并选择选项**编辑模板- >创建副本**就足够了。这样，该工具将生成应用于控件的所有默认样式的副本，包括一个名为`Template`的副本，其中包含所有可用视觉状态的列表。如果您尝试在`Button`控件上执行此操作，您会发现该控件可以呈现许多视觉状态，如`Pressed`或`Disabled`。

视觉状态在实现通用视窗平台应用程序最重要的要求之一:自适应布局中起着关键作用。由于视觉状态，我们将能够根据屏幕大小定义应用程序页面的外观，并根据可用空间更改页面的视觉布局。例如，当应用程序在大屏幕上运行时，一个页面可能会并排显示两个控件，但是有了可视状态，当应用程序在较小的屏幕上运行时，我们可以将这两个控件一个在另一个下面堆叠。

在本系列的下一本书中，我们将了解更多关于实现自适应布局和正确支持不同屏幕和设备的技术，该书专门介绍如何创建用户界面。

数据绑定是 XAML 最强大的功能之一，如果你想认真对待 Windows 开发，学习它是至关重要的。数据绑定是在用户界面和数据源(可以是代码中的控件或属性)之间创建通信通道的一种方式。此外，XAML 框架提供了一个与数据绑定相连接的通知机制(稍后将详细介绍)，可以创建实时通道。每当频道的一边发生变化，另一边就会自动得到通知和更新。

当您设置绑定时，您创建了一个通信通道，该通道涉及一个**源**(数据源)和一个**目标**(用户界面中向用户显示数据的控件)。作为默认行为，通道在`OneWay`模式下创建。当源发生变化时，目标会自动更新，但不会反过来。绑定是使用一个称为`Binding`的特定标记扩展来定义的，如下例所示:

代码清单 40

```
  <TextBlock Text="{Binding
  Path=FirstName}"
  />

```

在这种情况下，使用`Path`属性在标记扩展中指定源(在前面的示例中，它是一个名为`Name`的属性)。目标是绑定被分配的属性(在本例中为`Text`属性)。指定`Path`属性是可选的—以下代码的工作方式完全相同:

代码清单 41

```
  <TextBlock Text="{Binding FirstName}" />

```

然而，绑定也提供了一种创建双向通信通道的方法。例如，`TextBox`控件不仅可以用来显示文本，还可以接收用户输入的文本。在这种情况下，我们不仅需要在用户界面中反映代码的更改，还需要在用户插入代码时能够从代码中访问文本。为了支持这种情况，我们需要显式设置绑定的`Mode`属性，如下例所示:

代码清单 42

```
  <TextBox Text="{Binding
  Path=FirstName, Mode=TwoWay}" />

```

还有第三个`Mode`选项`OneTime`。有了它，只有在第一次加载页面时，才会评估绑定。当我们想要连接我们确信在应用程序执行期间不会改变的数据时，这很有用。

几乎所有的 XAML 控件都可以使用数据绑定。事实上，它们的大多数属性都被定义为依赖属性，这是特殊的属性，除了提供读写它们的值的标准机制之外，还支持通知传播。

让我们看一个例子来更好地理解这个概念。请看下面的代码片段:

代码清单 43

```
  <StackPanel>
      <Slider x:Name="Volume" />
      <TextBlock x:Name="SliderValue" Text="{Binding ElementName=Volume, Path=Value}" />
  </StackPanel>

```

在这个示例中，我们已经将`TextBlock`控件的`Text`属性连接到了`Slider`属性。我们仍然在使用`Binding`标记扩展，但是使用了不同的方法。我们没有仅仅使用`Path`属性，而是首先添加了`ElementName`属性。这样，我们可以引用页面中的另一个控件。在这种情况下，我们参考`Slider`控件的`Value`属性，它包含滑块的值。`Value`和`Text`都是依赖属性，所以它们可以在发生变化时传播通知。结果是，每次用户在屏幕上移动滑块时，`TextBlock`会自动更新自己以显示滑块的值。

#### 与对象的数据绑定

最强大的数据绑定功能之一是能够将可视控件连接到代码中的对象。这种方法是许多重要的 XAML 概念和模式的基础，比如模型-视图-视图模型。然而，为了解释这一点，我们必须首先引入一个新的 XAML 物业，称为`DataContext`。它的目的是定义控件的绑定上下文，和许多其他 XAML 特性一样，它是分层的。一旦定义了一个控件的`DataContext`，每隔一个嵌套的控件将获得对相同绑定上下文的访问。

让我们看一个例子:我们将使用数据绑定方法显示一个人的信息，而不是手动设置`TextBlock`控件的`Text`属性。信息存储在一个类中，该类包含一些基本信息(姓名):

代码清单 44

```
  public class Person
  {
      public string FirstName { get; set; }
      public string Surname { get; set; }
  }

```

以下是我们将用来在页面上显示此类信息的 XAML:

代码清单 45

```
  <StackPanel x:Name="Customer">
      <TextBlock Text="First
  Name" />
      <TextBlock Text="{Binding Path=FirstName}" />
      <TextBlock Text="Surname"
  />
      <TextBlock Text="{Binding Path=Surname}" />
  </StackPanel>

```

如您所见，姓名是使用数据绑定显示的。使用`Binding`标记表达式将`Person`类的两个属性连接到`TextBlock`控件。现在让我们看看如何创建`Person`对象，以及如何使用这种新方法显示它:

代码清单 46

```
  public MainPage()
  {

  InitializeComponent();
      Person person = new Person();
      person.FirstName = "Matteo";

  person.Surname = "Pagani";

  Customer.DataContext = person;
  }

```

创建页面时，我们定义一个新的`Person`对象，并将其设置为`Customer`控件的`DataContext`，这是包含用于显示姓名的`TextBlocks`的`StackPanel`。通过这样做，我们已经将刚刚创建的`Person`对象定义为`StackPanel`的绑定上下文。这样，我们可以使用绑定来访问`FirstName`和`Surname`属性。

#### INotifyPropertyChanged 接口

之前的代码有一个缺陷。与我们在`Slider`控件中看到的示例不同，如果您在运行时更改`Person`类的一个属性，在应用程序执行期间，`TextBlock`控件不会更新自己来显示新值。出现这种情况是因为`Name`和`Surname`是简单属性，而不是依赖属性。如果您想启用通知的传播支持，通用视窗平台提供了一个名为`INotifyPropertyChanged`的特定接口，您应该在您的类中实现它。

让我们看看我们之前看到的`Person`类定义是如何改变以正确支持这个接口的:

代码清单 47

```
  public class Person : INotifyPropertyChanged
  {
      private string _firstName;
      private string _surname;
      public string FirstName
      {
          get { return _firstName; }
          set
          {
              _firstName =
  value;

  OnPropertyChanged();
          }
      }
      public string Surname
      {
          get { return _surname; }
          set
          {
              _surname = value;

  OnPropertyChanged();
          }
      }
      public event PropertyChangedEventHandler PropertyChanged;
      protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
      {
          PropertyChangedEventHandler handler = PropertyChanged;
          if (handler != null)
  {
   handler(this, new PropertyChangedEventArgs(propertyName));
  }
      }
  }

```

感谢`INotifyPropertyChanged` `interface,`我们能够定义一个名为`PropertyChanged`的事件，它是由`OnPropertyChanged()`方法引发的。每次调用它时，我们都会通知用户界面属性的值已经更改。

第二步是更改属性定义。它们不能再是简单的属性，因为我们需要在每次值改变时调用`OnPropertyChanged()`方法。我们在房产的设定者那里做这件事。

现在，数据绑定提供的通知机制将正常工作。如果您在应用程序运行时更改了个人的姓名，您将在用户界面中正确地看到新值。

#### 数据绑定和集合

当您必须处理数据集合时，数据绑定起着关键作用。每个可以显示集合的控件都实现一个名为`ItemsSource`的属性，该属性包含要在页面中显示的数据。

我们在本章前面已经看到了如何定义`DataTemplate`以及如何在集合中使用它。每当您将一组数据分配给`ItemsSource`属性时，在引擎盖下，您将属于集合的单个项目设置为`ItemTemplate`的`DataContext`。

让我们看一个带有`ListView`控件的示例，它使用了我们之前看到的`DataTemplate``ItemTemplate`:

代码清单 48

```
  <ListView x:Name="People" >
      <ListView.ItemTemplate>
          <DataTemplate>
              <StackPanel>
                  <TextBlock Text="First
  Name" />
                  <TextBlock Text="{Binding Path=FirstName}" />
                  <TextBlock Text="Surname"
  />
                  <TextBlock Text="{Binding Path=Surname}" />
              </StackPanel>
          </DataTemplate>
      </ListView.ItemTemplate>
  </ListView>

```

下面是我们如何在代码中将数据集合分配给`ListView`控件:

代码清单 49

```
  public MainPage()
  {

  InitializeComponent();
      List<Person>
  people = new List<Person>
      {
          new Person
          {
              FirstName = "Matteo",
              Surname = "Pagani"
          },
          new Person
          {
              FirstName = "Angela",
              Surname = "Olivieri"
          }
      };

      People.ItemsSource =
  people;
  }

```

由于集合被指定为`ListView`控件的`ItemsSource`，因此`ItemTemplate`的`DataContext`成为单个`Person`对象。因此，我们能够使用绑定来显示`FirstName`和`Surname`属性的值。

管理集合和数据绑定的另一个重要类是`ObservableCollection<T>`类。它的行为就像一个常规的集合，但是在引擎盖下，它实现了`INotifyPropertyChanged`接口。因此，每次集合改变时(添加或删除新项目，项目顺序改变等)。)，连接到它的控件将自动直观地反映新的更改。

需要强调的是`ObservableCollection<T>`类只能通知你集合的变化。如果您还想在集合中的某个项目的属性发生变化时得到通知，您仍然需要在您的类中手动实现`INotifyPropertyChanged`接口。

#### 转换器

有时候，您的应用程序中可能有一些数据，但是，当它显示在页面上时，您不想按原样显示它，您想先执行一些更改。一个常见的例子是当你必须处理一个`DateTime`对象时。如果您想显示新闻文章的列表，可能只显示新闻的日期就足够了，而不是显示小时、分钟、秒和毫秒的完整表示。

转换器是能够满足这一要求的特殊类别。它们在源数据发送到目标控件之前拦截源数据。为了正常工作，这些类需要实现`IValueConverter`接口，如下例所示:

代码清单 50

```
  public class DateTimeConverter : IValueConverter
  {
      public object Convert(object value, Type
  targetType, object parameter, string language)
      {
          if (value != null)
          {
              DateTime date = (DateTime)value;
              //the following line formats the
  DateTime object to return just the date, without the time information 
              return date.ToString("d);
          }
          return string.Empty;
      }

      public object ConvertBack(object value, Type
  targetType, object parameter, string
      language)
      {
          if (value != null)
          {
              DateTime date = DateTime.Parse(value.ToString());
              return date;
          }
          return DateTime.Now;
      }
  }

```

通过实现`IValueConverter`接口，您将被迫定义两种方法。`Convert()`是当源数据被截获，需要修改后才能发送到目标时调用的。`ConvertBack()`方法在相反的场景中被调用:当目标需要将数据发送回源时。该方法仅在定义双向绑定时调用，否则只需要实现`Convert()`方法。

这两种方法都将接收一些信息作为执行转换所需的输入参数。最重要的是`value`，包含源数据。由于绑定可以应用于任何对象，`value`的类型是通用的`object`。根据您的场景，您必须将其正确转换为您期望的类型。

前面的例子参考了我们之前介绍的`DateTime`场景。`Convert()`方法只返回日期，而`ConvertBack()`方法获取输入字符串并将其转换回`DateTime`对象。

转换器像常规资源一样管理。它们需要在控件、页面或应用程序本身提供的`Resources`属性中定义。然后，您可以使用`StaticResource`标记扩展将它们应用于绑定表达式中的`Converter`属性。以下示例显示了如何将先前声明的转换器声明为资源，以及如何将其应用于`TextBlock`控件:

代码清单 51

```
  <Page
      x:Class="SampleProject.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <Page.Resources>
          <converters:DateTimeConverter
  x:Key="DateConverter" />
      </Page.Resources>

      <TextBlock Text="{Binding Path=BirthDate, Converter={StaticResource DateConverter}}" />

  </Page>

```

如果您想要添加一个参数(它将被分配给包含在 `Convert()`和`ConvertBack()`方法的签名中的名为`parameter`的属性)，您只需要向标记扩展添加一个`ConverterParameter`属性，如下例所示:

代码清单 52

```
  <Page
      x:Class="SampleProject.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <Page.Resources>
          <converters:DateTimeConverter
  x:Key="DateConverter" />
      </Page.Resources>

      <TextBlock Text="{Binding Path=BirthDate, Converter={StaticResource DateConverter}, ConverterParameter=ShortDate}"
  />

  </Page>

```

必须强调的是，转换器不应被滥用。它们会对性能产生负面影响，因为每次绑定表达式改变时都需要调用转换器的逻辑。在更复杂的情况下，最好直接修改原始属性，或者在类中定义一个新属性来保存要显示的值。

#### 数据模板选择器

有时，转换器不仅用于在显示数据之前更改数据，还用于根据数据更改控件的视觉布局(例如，您想要隐藏或显示数据或更改其属性之一，如颜色)。然而，由于前面提到的潜在性能问题，这种方法并不总是最好的解决方案，尤其是如果您需要基于数据深入地改变布局。

对于这些场景，通用视窗平台提供了一种更好的方法`DataTemplateSelector`，这是一个特殊的类，可以根据我们的需求返回不同的`DataTemplate`。这样，我们就不必创建一个包含大量转换器的布局，我们只需定义两个(或更多)不同的模板。基于我们的需求，数据将使用适当的一个渲染。

为了了解这个特性是如何工作的，让我们通过添加一个名为`Sex`的新属性来改变我们之前看到的`Person`类，它将告诉我们这个人是男性还是女性:

代码清单 53

```
  public class Person
  {
      public string FirstName { get; set; }
      public string Surname { get; set; }
      public char Sex { get; set; }
  }

```

我们的目标是根据性别显示不同模板的人员列表。男性的背景是蓝色的，女性的背景是粉色的。为此，我们需要创建一个从`DataTemplateSelector`继承的类，并定义可用的`DataTemplate`对象和用于决定应用哪个对象的条件。以下是完整的示例:

代码清单 54

```
  public class PeopleTemplateSelector : DataTemplateSelector
  {
      public DataTemplate MaleTemplate { get; set; }

      public DataTemplate FemaleTemplate { get; set; }

      protected override DataTemplate SelectTemplateCore(object item, DependencyObject container)
      {
          Person person = item as Person;
          if (person != null)
          {
              if (person.Sex=='M')
              {
                  return MaleTemplate;
              }
              else
              {
                  return FemaleTemplate;
              }
          }
          return base.SelectTemplateCore(item, container);
      }
  }

```

在我们的场景中，我们将使用两个模板。因此，该类定义了两个不同的`DataTemplate`对象，一个用于男性模板，一个用于女性模板。通过实现`DataTemplateSelector`类，我们被迫定义`SelectTemplateCore()`方法，该方法在执行绑定时在运行时被调用。该方法将告诉显示数据集合的控件使用哪个模板。为此，该方法接收集合的当前项目作为通用`object`作为输入参数。第一步是将其转换为我们正在使用的类型(在我们的例子中是`Person`类)。然后我们可以检查我们感兴趣的条件，并返回适当的`DataTemplate`。在我们的示例中，我们检查了`Gender`属性的值。如果等于`M`，则退回`MaleTemplate`，否则退回`FemaleTemplate`。

到目前为止，我们已经定义了`PeopleTemplateSelector`的逻辑。现在我们需要通过指定两个模板的外观来定义视觉布局。为此，我们简单地将两个`DataTemplates`定义为资源，就像我们通常会做的那样:

代码清单 55

```
  <Page.Resources>
      <DataTemplate x:Key="MaleTemplate">
          <StackPanel Width="300" Background="LightBlue">
              <TextBlock Text="{Binding Path=FirstName}" />
              <TextBlock Text="{Binding Path=Surname}" />
          </StackPanel>
      </DataTemplate>

      <DataTemplate x:Key="FemaleTemplate">
          <StackPanel Width="300" Background="Pink">
              <TextBlock Text="{Binding Path=FirstName}" />
              <TextBlock Text="{Binding Path=Surname}" />
          </StackPanel>
      </DataTemplate>
  </Page.Resources>

```

可以看到，除了应用到`StackPanel`控件的背景颜色外，两个模板基本相同。现在我们也需要将之前创建的`PeopleTemplateSelector`对象定义为资源:

代码清单 56

```
  <Page.Resources>
      <DataTemplate x:Key="MaleTemplate">
          <StackPanel Width="300" Background="LightBlue">
              <TextBlock Text="{Binding Path=FirstName}" />
              <TextBlock Text="{Binding Path=Surname}" />
          </StackPanel>
      </DataTemplate>
      <DataTemplate x:Key="FemaleTemplate">
          <StackPanel Width="300" Background="Pink">
              <TextBlock Text="{Binding Path=FirstName}" />
              <TextBlock Text="{Binding Path=Surname}" />
          </StackPanel>
      </DataTemplate>

      <local:PeopleTemplateSelector x:Key="PeopleTemplateSelector" 
       MaleTemplate="{StaticResource MaleTemplate}"
       FemaleTemplate="{StaticResource FemaleTemplate}" />
  </Page.Resources>

```

如果您还记得的话，在`PeopleTemplateSelector`对象中，我们已经为每个需要管理的`DataTemplate`定义了一个属性。现在我们只需要确定每个属性使用哪个`DataTemplate`。因为它们只是资源，所以我们使用`StaticResource`标记扩展，就像我们使用任何其他资源一样。

最后一步是给我们将要用来显示数据集合的控件分配`DataTemplateSelector`。我们可以通过使用大多数集合控件公开的`ItemTemplateSelector`属性来实现。以下示例显示了如何使用`GridView`控件进行操作:

代码清单 57

```
  <GridView ItemTemplateSelector="{StaticResource PeopleTemplateSelector}" />

```

如您所见，在这种情况下，我们不需要定义`ItemTemplate`属性。我们创建的`PeopleTemplateSelector`对象将根据我们编写的逻辑为每个项目分配适当的`ItemTemplate`。

数据绑定非常强大，但也有一些缺点:

*   它是在运行时评估的，因此会对应用程序的性能产生负面影响。事实上，绑定是使用反射实现的，这意味着 XAML 渲染引擎必须遍历整个 XAML 树来找到正确的控件并应用正确的值。
*   在运行时进行评估，在执行应用程序之前，您不会发现错误。你还记得我们之前看到的`Person`类的定义吗，它包含`FirstName`和`Surname`属性？假设，在某个时候，您创建了以下`DataTemplate`与`ListView`一起使用:

代码清单 58

```
  <ListView x:Name="People" >
      <ListView.ItemTemplate>
          <DataTemplate>
              <StackPanel>
                  <TextBlock Text="First
  Name" />
                  <TextBlock Text="{Binding Path=FirstName}" />
                  <TextBlock Text="Surname"
  />
                  <TextBlock Text="{Binding Path=Surame}"
  />
              </StackPanel>
          </DataTemplate>
      </ListView.ItemTemplate>
  </ListView>

```

正如我用黄色突出显示的，示例代码故意包含一个错误。`Person`类有一个属性叫做`Surname`，但是我们在`DataTemplate`中称之为`Surame`。但是，由于绑定是在运行时评估的，所以在 Visual Studio 中编译应用程序时不会出现任何错误。您会注意到该错误，只是因为当应用程序运行时，您会看到姓氏字段为空，并且输出窗口中有一条消息报告绑定有问题。

为了解决这两个问题，通用视窗平台引入了一个新的标记表达式`x:Bind`，它将在构建过程中被编译。因此，它的速度要快得多，如果您像前面的例子中那样出现任何错别字，您会立即注意到它，因为构建过程将会失败。

从代码的角度来看，这两个标记表达式的工作方式是相同的，所以用`x:Bind`替换`Binding`就足够了，可以开始使用它，如下例所示:

代码清单 59

```
  <StackPanel x:Name="Customer">
      <TextBlock Text="First
  Name" />
      <TextBlock Text="{x:Bind Path=FirstName}" />
      <TextBlock Text="Surname"
  />
      <TextBlock Text="{x:Bind Path=Surname}" />
  </StackPanel>

```

然而，有一些重要的区别需要记住。

我们已经看到绑定是通过`DataContext`属性处理的。当我们使用`Binding`标记表达式时，XAML 基础结构将在我们为控件设置的`DataContext`中寻找属性，或者，如果没有属性，将遵循层次结构到达由父控件定义的第一个属性。

因此，例如，这些属性可以在我们项目的一个完全不同的类中声明。这是模型-视图-视图模型模式背后的基本概念之一。这种模式可以消除表示层和数据层之间的依赖关系，因为我们可以为页面设置一个普通的类(称为视图模型)作为`DataContext`，它将负责定义属性和交互逻辑。因为它是一个普通的类(不像代码隐藏，它对 XAML 页面有很强的依赖性)，我们可以很容易地实现像单元测试、代码隔离等过程。

`x:Bind`，相反，由于它被编译，将使用代码隐藏类作为`DataContext`。因此，在前面的示例中，我们必须在代码隐藏类中声明`FirstName`和`Surname`属性，而不是在单独的类中，如下例所示:

代码清单 60

```
  public sealed partial class MainPage : Page
  {
      public string FirstName { get; set; }

      public string Surname { get; set; }
      public MainPage()
      {
          this.InitializeComponent();
          FirstName = "Matteo";
          Surname = "Pagani";
      }
  }

```

如果你想两全其美(利用`x:Bind`，但同时也设置`DataContext`，这样你就可以在一个单独的类中定义你的属性)，解决方案是在代码隐藏类中创建一个属性，用`DataContext`的值填充。这样，您将能够通过该属性使用`x:Bind`表达式访问`DataContext`提供的所有属性。

浏览 MVVM 模式的细节对于这个解释来说是不切实际的，但是让我们看一个具有基本实现的真实例子，并假设您的 XAML 页面具有以下定义:

代码清单 61

```
  <Page
      x:Class="SampleProject.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      DataContext="{StaticResource MainViewModel}"
      mc:Ignorable="d">

      <StackPanel>
          <TextBlock Text="First
  Name" />
          <TextBlock Text="{Binding Path=FirstName}" />
          <TextBlock Text="Surname"
  />
          <TextBlock Text="{Binding Path=Surname}" />
      </StackPanel>

  </Page>

```

由于我们已经将一个名为`MainViewModel`的资源(这是我们项目中包含的一个类)设置为整个`Page`的`DataContext`，因此我们可以通过标准绑定来访问这个类定义的`FirstName`和`Surname`属性。因此，`MainViewModel`类可能是这样的:

代码清单 62

```
  public class MainViewModel
  {
      public string FirstName { get; set; }

      public string Surname { get; set; }
  }

```

然而，如前所述，如果我们简单地将`Binding`表达式与`x:Bind`表达式交换，我们将得到一个编译时异常，因为`DataContext`属性将被忽略，编译器将在这个 XAML 页面的代码隐藏中寻找不存在的`FirstName`和`Surname`属性。因此，我们可以在代码隐藏中创建一个属性来保存对`MainViewModel`实例的引用，如下例所示:

代码清单 63

```
  public sealed partial class MainPage : Page
  {
      public MainViewModel ViewModel { get; set; }
      public MainPage()
      {
          this.InitializeComponent();
          ViewModel =
  DataContext as MainViewModel;
      }
  }

```

我们只需创建一个属性，一个`MainViewModel`类型，并在页面的构造函数中存储页面的`DataContext`属性的值(我们需要首先执行强制转换，因为`DataContext`属性可以是任何类型，所以它是一个泛型对象)。

现在，我们可以简单地通过使用我们刚刚创建的`ViewModel`属性来开始利用`x:Bind`，如下例所示:

代码清单 64

```
  <Page
      x:Class="SampleProject.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      DataContext="{StaticResource MainViewModel}"
      mc:Ignorable="d">

      <StackPanel>
          <TextBlock Text="Name"
  />
          <TextBlock Text="{x:Bind Path=ViewModel.FirstName}" />
          <TextBlock Text="Surname"
  />
          <TextBlock Text="{x:Bind Path=ViewModel.Surname}" />
      </StackPanel>

  </Page>

```

将`ViewModel`前缀附加到我们想要使用的`MainViewModel`类的属性名称上，加上一个点就足够了。

默认情况下，当我们使用标准的`Binding`表达式创建绑定时，应用的`Mode`是`OneWay`，这意味着源中的每个变化都会反映在目标中，但不会反过来。如果我们将这个概念应用到我们之前的示例中，这意味着每次我们更改`Name`或`Surname`属性的值，并且我们已经正确实现了`INotifyPropertyChanged`界面，`TextBlock`控件将自动更新其视觉布局以反映新的值。

而对于`x:Bind`标记表达式，默认值是`OneTime`。这意味着绑定表达式将仅在创建页面时计算，然后其他更改将不再传播。这种模式的目标是节省性能。在开发过程中，经常会创建绑定通道，这些通道会不断地监听更改，尽管最终它们在应用程序的生命周期中从未真正更新过。如果我们真的需要将源中的更改传播到目标，我们需要将`x:Bind`表达式的`Mode`属性明确指定为`OneWay`，如下例所示:

代码清单 65

```
  <Page
      x:Class="SampleProject.MainPage"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d">

      <StackPanel>
          <TextBlock Text="Name"
  />
          <TextBlock Text="{x:Bind Path=FirstName, Mode=OneWay}"
  />
          <TextBlock Text="Surname"
  />
          <TextBlock Text="{x:Bind Path=Surname, Mode=OneWay}"
  />
      </StackPanel>

  </Page>

```

使用`x:Bind`的另一个区别来自于你需要创建一个`DataTemplate`。由于模板不依赖于代码隐藏类，编译器不知道在哪里查找属性。因此，同样，我们不能简单地用`x:Bind`替换`Binding`表达式；我们还需要指定我们要用`DataTemplate`表示的数据类型。

在前面的示例中，我们已经看到了如何创建代表`Person`对象内容的`DataTemplate`:

代码清单 66

```
  <ListView x:Name="People" >
      <ListView.ItemTemplate>
          <DataTemplate>
              <StackPanel>
                  <TextBlock Text="First
  Name" />
                  <TextBlock Text="{Binding Path=FirstName}" />
                  <TextBlock Text="Surname"
  />
                  <TextBlock Text="{Binding Path=Surname}" />
              </StackPanel>
          </DataTemplate>
      </ListView.ItemTemplate>
  </ListView>

```

下面是我们需要如何更改它以使用新的标记表达式:

代码清单 67

```
  <ListView x:Name="People" >
      <ListView.ItemTemplate>
          <DataTemplate x:DataType="local:Person">
              <StackPanel>
                  <TextBlock Text="First
  Name" />
                  <TextBlock Text="{x:Bind Path=FirstName}" />
                  <TextBlock Text="Surname"
  />
                  <TextBlock Text="{x:Bind Path=Surname}" />
              </StackPanel>
          </DataTemplate>
      </ListView.ItemTemplate>
  </ListView>

```

我们已经将属性`x:DataType`添加到了`DataTemplate`中，引用了我们需要用模板表示的基本实体(由于`Person`不是通用视窗平台的基本控件，我们需要使用自定义命名空间来引用它，就像我们在本章开头学习的那样)。有了这个变化，我们现在可以正确地使用`x:Bind`而不是`Binding`了。

到目前为止，我们将注意力集中在使用标准`Binding`标记表达式和新的`x:Bind`标记表达式之间的主要区别上。然而，`x:Bind`不仅带来了更好的性能和更少的出错机会，还增加了一组标准绑定没有的功能。让我们看看最重要的。

#### 与事件绑定

我们已经看到，传统的`Binding`表达式只能用于将 XAML 控件的属性与类中声明的属性联系起来。`x:Bind`还允许您通过将相同的绑定语法应用于事件而不是属性来连接方法。例如，下面是我们如何将方法绑定到由`Button`控件暴露的`Click`事件:

代码清单 68

```
  <Button Click="{x:Bind Path=SayHello}"
  />

```

通用视窗平台将有望找到一种在代码隐藏中定义的名为`SayHello`的方法。声明此方法有两种受支持的方法:

*   通过使其无参数化(这是标准事件处理程序订阅不支持的功能)，如下例所示:

代码清单 68

```
  public void
  SayHello()
  {
      Message = "Hello world";
  }

```

*   通过匹配原始事件处理程序的签名，就像我们以常规方式订阅事件一样:

代码清单 69

```
  public void
  SayHello(object sender, RoutedEventArgs e)
  {
      Message = "Hello world";
  }

```

#### 使用 x:阶段和 x:延迟策略属性提高性能

`x:Phase`是一个新属性，可以与使用`x:Bind`表达式渲染属性的控件结合使用。当您定义将与集合控件(如`ListView`)一起使用的`DataTemplate`并希望优化性能时，此属性非常有用。例如，假设您已经声明了以下`DataTemplate`，它将被用作`ListView`控件的`ItemTemplate`，该控件可能会显示数千个项目:

代码清单 70

```
  <DataTemplate x:DataType="local:Person">
      <Grid>
          <Grid.ColumnDefinitions>
              <ColumnDefinition Width="1*"
  />
              <ColumnDefinition Width="2*"
  />
          </Grid.ColumnDefinitions>

          <Image Grid.Column="0" Source="{x:Bind Path=Photo}"
  />
          <StackPanel Grid.Column="1">
              <TextBlock Text="{x:Bind Path=FirstName}" />
              <TextBlock Text="{x:Bind Path=Surname}" />
          </StackPanel>
      </Grid>
  </DataTemplate>

```

如您所见，该模板除了仅显示一些文本数据(姓名)之外，还显示了一张照片图像，这可能需要更多的时间来渲染(尤其是如果它存储在远程服务器上而不是本地)。当用户滚动列表时，这可能会影响列表的整体性能，因为直到下载并呈现图像后，每个项目才会完全显示出来。

为了减少这个问题，我们可以利用`x:Phase`属性来定义模板中项目的渲染顺序。下面是我们如何改变之前的`DataTemplate`来利用这个特性:

代码清单 71

```
  <DataTemplate x:DataType="local:Person">
      <Grid>
          <Grid.ColumnDefinitions>
              <ColumnDefinition Width="1*"
  />
              <ColumnDefinition Width="2*"
  />
          </Grid.ColumnDefinitions>

          <Image Grid.Column="0" Source="{x:Bind Path=Photo}" x:Phase="2" />
          <StackPanel Grid.Column="1">
              <TextBlock Text="{x:Bind Path=FirstName}" x:Phase="0" />
              <TextBlock Text="{x:Bind Path=Surname}" x:Phase="1" />
          </StackPanel>
      </Grid>
  </DataTemplate>

```

我们已经将`x:Phase`属性添加到`DataTemplate`内的每个控件中，并且通过简单地使用一个序数，我们已经定义了渲染顺序。在前面的示例中，名字和姓氏(纯字符串)将首先呈现，而图像(呈现时间较长)将最后显示。

为了进一步提高性能，我们可以利用另一个名为`x:DeferLoadStrategy`的属性，我们可以使用它来启用延迟加载。前面的例子，其实会给出比较愉悦的用户体验，但是渲染性能会是一样的。这是因为`x:Phase`影响的是控制的`Opacity`，而不是`Visibility`。这两个属性的区别在于，当您将控件的`Opacity`设置为 0 时，它仍然呈现在 XAML 树中，但不可见。当设置为`Collapsed`时，`Visibility`属性阻止在 XAML 树中添加控件。结果是，当您仅利用`x:Phase`属性时，元素仍然呈现在 XAML 树中，因此会消耗内存。

相反，通过将`x:DeferLoadStrategy`设置为`Lazy`，`x:Phase`属性将影响控件的`Visibility`属性，从而在控件尚未完全渲染时帮助节省内存。

以下是为利用这一额外属性而更新的`DataTemplate`的外观:

代码清单 72

```
  <DataTemplate x:DataType="local:Person">
      <Grid>
          <Grid.ColumnDefinitions>
              <ColumnDefinition Width="1*"
  />
              <ColumnDefinition Width="2*"
  />
          </Grid.ColumnDefinitions>

          <Image Grid.Column="0" Source="{x:Bind Path=Photo}" 
                  x:Phase="2" x:DeferLoadStrategy="Lazy"
                  x:Name="Photo" />
          <StackPanel Grid.Column="1">
              <TextBlock Text="{x:Bind Path=FirstName}"
                          x:Phase="0" x:DeferLoadStrategy="Lazy" 
                          x:Name="FirstName"/>
              <TextBlock Text="{x:Bind Path=Surname}" x:Phase="1" 
                          x:DeferLoadStrategy="Lazy" x:Name="Surname" />
          </StackPanel>
      </Grid>
  </DataTemplate>

```

只有一件重要的事情需要强调:为了正常工作，`x:DeferLoadStrategy`属性要求每个控件都由`x:Name`属性标识。否则，当开始渲染时，XAML 基础设施将无法找到它们。

一般来说，`x:DeferLoadStrategy`不仅可以和`DataTemplates`一起使用，还可以和 XAML 页面中的每个控件一起使用。当您将`x:DeferLoadStrategy`设置为`Lazy`时，控件及其子控件不会被渲染，直到有人试图以某种方式引用它，例如:

*   使用绑定。
*   使用`Storyboard`开始动画。
*   在代码隐藏类中使用通用 Windows 平台提供的`FindName()`方法。

请看下面的 XAML 代码示例:

代码清单 73

```
  <Grid x:Name="DeferredGrid" x:DeferLoadStrategy="Lazy">
      <Grid.RowDefinitions>
          <RowDefinition Height="Auto"
  />
          <RowDefinition Height="Auto"
  />
      </Grid.RowDefinitions>
      <Grid.ColumnDefinitions>
          <ColumnDefinition Width="Auto"
  />
          <ColumnDefinition Width="Auto"
  />
      </Grid.ColumnDefinitions>

      <Rectangle Height="100" Width="100" Fill="#F65314" Margin="0,0,4,4" />
      <Rectangle Height="100" Width="100" Fill="#7CBB00" Grid.Column="1" Margin="4,0,0,4" />
      <Rectangle Height="100" Width="100" Fill="#00A1F1" Grid.Row="1" Margin="0,4,4,0" />
      <Rectangle Height="100" Width="100" Fill="#FFBB00" Grid.Row="1" Grid.Column="1" Margin="4,4,0,0" />
  </Grid>
  <Button x:Name="RealizeElements" Content="Realize Elements" Click="RealizeElements_Click" />
  </Grid>

```

由于名称为`DeferredGrid`的`Grid`将`x:DeferLoadStrategy`属性设置为`Lazy`，因此加载页面时，其中定义的`Rectangle`控件都不会呈现在 XAML 树中。然而，一旦有人试图获取对`DeferredGrid`控件的引用，`Visibility`将自动从`Collapsed`更改为`Visible`，强制所有`Rectangle`控件渲染并添加到 XAML 树中。

在示例代码中，您可以看到有一个名为`RealizeElements`的`Button`控件。单击它时，它将执行以下代码:

代码清单 74

```
  private void
  RealizeElements_Click(object sender, RoutedEventArgs e)
  {
      this.FindName("DeferredGrid"); // This
  will realize the deferred grid
  }

```

这是一个触发控件渲染的操作示例，因为我们调用`FindName()`方法来获取对`DeferredGrid`方法的引用。

在本系列的下一本书中，我们将学习在应用程序中实现自适应布局体验的不同技术，这种方法将被证明非常有用。由于`x:DeferLoadStrategy`属性，我们可以完全避免加载屏幕空间不足时不显示的控件。

在前面的段落中，我们已经看到了许多铸造样品。转换意味着将对象从一种类型转换为另一种类型。当然，要想手术成功，两种类型应该兼容。例如，我们可以很容易地将一个`int`转换成一个`double`，但我们不能反其道而行之，因为如果数字是十进制的，就不能隐式转换成整数。

在其他一些情况下，我们使用泛型`object`类型的属性(就像我们在`DataContext`类型中看到的那样)，因为它们可以接受多个类型作为值。这样，借助 cast，我们可以将通用的`object`转换为我们期望的类型，就像我们在讨论转换器时看到的那样。

强制转换是通过在变量的括号之间加上类型前缀来实现的。例如，下面是我们如何将整数转换为浮点类型:

代码清单 75

```
  int a = 1;
  double b = (int)
  a;

```

在周年更新之前，选角只能在代码隐藏的世界中使用。有了这个新的更新，您也可以在 XAML 利用`x:Bind`表达式自动将源绑定从一种类型转换为另一种类型，而不需要显式的转换器。

让我们看一个非常常见的场景的真实例子:处理控件的可见性。大多数情况下，当您需要根据逻辑中的条件隐藏或显示控件时，C#代码和 XAML 不匹配。在 C#中，通常使用`bool`属性来表示这种情况。相反，在 XAML，控件的可见性由`Visibility`属性处理，该属性是接受值`Visible`或`Collapsed`的枚举器。因此，在每个项目中，您通常会创建一个转换器，该转换器将`bool`值作为输入，并返回`Visibility`枚举器的相应值。

多亏了这个新功能，我们可以直接在 XAML 应用演员阵容。例如，假设在代码隐藏中，您有一个`bool`属性，用于确定互联网连接是否可用。

代码清单 76

```
  public sealed partial class MainPage : Page
  {
      public bool IsInternetAvailable { get; set; }
  }

```

现在，如果您想要隐藏或显示基于该属性值的控件，可以简单地在 XAML 使用强制转换。以下示例显示了如何基于`IsInternetAvailable`属性的值在 XAML 页面中隐藏或显示`Button`:

代码清单 77

```
  <Button Content="This is a
  button" 
          Visibility="{x:Bind
  ((Visibility)IsInternetAvailable)}" />

```

如您所见，语法与我们在 C#中使用的相同。在`x:Bind`标记表达式之后，我们指定我们想要连接的属性，前缀是我们想要用于大括号内转换的类型。

周年更新中增加的另一个功能是`x:Bind`对功能的支持。我们可以将控件的属性与一个简单的属性绑定到一个函数上，而不是在代码中将它与一个简单的属性绑定，每当其中一个参数发生变化时，就会自动对该函数进行求值。

让我们重复使用前面的示例代码，其中我们在代码隐藏类中添加了两个名为`FirstName`和`Surname`的属性，然后使用两个`TextBlock`控件和`x:Bind`表达式将其显示在 XAML 页面中。

现在，假设我们想添加一个新的`TextBlock`，显示用户的全名(这意味着名字和姓氏在同一个字符串中)。过去，我们必须在代码隐藏中创建一个新属性，在代码中执行字符串连接，然后将结果分配给这个新属性。

从周年更新开始，我们现在可以创建一个执行操作的方法，并在执行绑定时在 XAML 直接调用它。我们的代码隐藏是这样的:

代码清单 78

```
  public sealed partial class MainPage : Page
  {
      public string FirstName { get; set; }

      public string Surname { get; set; }

      public MainPage()
      {
          this.InitializeComponent();
          FirstName = "Matteo";
          Surname = "Pagani";
      }

      public string ComposeFullName(string name, string
  surname)
      {
          string fullname = $"{name} {surname}";
          return fullname;
      }
  }

```

我们在本章前面看到的示例中添加了一个名为`ComposeFullName()`的新方法，它接受两个字符串作为输入参数。在这个方法中，我们简单地利用新的 C# 6.0 特性来执行字符串连接(因此我们连接名字和姓氏，在中间添加一个空格)并返回结果。

现在，当我们建立绑定通道时，可以在 XAML 直接调用这个新方法:

代码清单 79

```
  <TextBlock Text="{x:Bind ComposeFullName(FirstName, Surname)}" />

```

这种方法的好处是，如果在应用执行过程中的某个时刻，`FirstName`和`Surname`属性的值发生了变化，`ComposeFullName()`方法将再次被自动调用，`TextBlock`将显示函数的更新结果。

异步编程是开发现代应用程序时最重要的概念之一。过去，大多数应用程序都是使用同步方法开发的。直到运行操作完成，应用程序基本冻结，用户没有机会与之交互。

这种方法不适用于现代应用程序。在当前应用程序完成任务之前，没有人会购买不允许用户接听电话、回复电子邮件或开始游戏的智能手机、平板电脑或控制台。通用视窗平台提供了两种不同的方法来管理异步编程:回调和异步等待模式。

如果您过去使用过其他开发平台，那么您可能使用过回调方法。然而，在通用视窗平台中，这种方法不再被广泛使用，因为大多数应用编程接口依赖异步和等待模式。尽管如此，仍有一些类在使用这种方法，尤其是当它们的目的是作为一个侦听器来检测什么时候发生了变化时(例如，地理定位服务使用回调方法来跟踪用户的移动)。

回调是委托方法，当异步操作结束或检测到与前一个值有变化时调用。使用这种方法，启动操作的代码和管理操作的代码由两种不同的方法处理。让我们看一些代码，基于前面提到的地理定位服务的例子，使用`Geolocator`类进行管理:

代码清单 80

```
  private void
  OnStartGeolocator(object sender, RoutedEventArgs e)
  {
      Geolocator geolocator = new Geolocator();

  geolocator.PositionChanged += geolocator_PositionChanged;
      Debug.WriteLine("Finding the user’s position…");
  }

  void geolocator_PositionChanged(Geolocator sender, PositionChangedEventArgs args)
  {
      Latitude.Text =
  args.Position.Coordinate.Latitude.ToString();
      Longitude.Text =
  args.Position.Coordinate.Longitude.ToString();
  }

```

如您所见，我们使用两种不同的方法来正确跟踪用户的位置。`OnStartGeolocator()`负责初始化`GeoLocator`类和订阅`PositionChanged`事件；真正的跟踪是由`geolocator_PositionChanged()`事件处理程序完成的，每次用户位置发生变化时都会调用该事件处理程序。

通常，用于管理回调的事件处理程序接收两个参数作为输入。第一个叫`sender`，是触发事件的对象；第二个包含一些有用的参数来了解发生了什么。在前面的示例中，您可以看到第二个参数的类型是`PositionChangedEventArgs`，它包含一个`Position`属性，带有用户位置的坐标。

我们刚刚写的代码是异步的。Visual Studio 的输出窗口中的消息(使用`Debug.Writeline()`方法打印)会在跟踪开始后立即显示。只有当检测到新的位置时，回调的方法才会被执行。

回调方法的缺点是让开发人员更难理解和管理代码。与同步代码不同，执行流程不是线性的，而是从一个方法跳到另一个方法。C# 5.0 中引入了异步和等待模式来解决这个问题；通用视窗平台严重依赖这种方法。定义一个可能需要超过 50 毫秒才能完成的操作的每个应用编程接口都已经使用它实现了。

当我们使用异步和等待模式时，我们像同步一样编写顺序代码。编译器将一条接一条地执行语句。在引擎盖下，编译器会在您每次启动异步操作时添加一个书签，然后退出当前方法。这样，用户界面线程将被释放，应用程序将继续快速响应。一旦异步操作终止，编译器将从先前设置的书签恢复执行。

异步和等待模式主要基于`Task`类，这是每个异步操作返回的基本类型。一个方法可以返回两种不同的类型:

*   `Task`，当它是一个`void`方法，不返回任何值给调用者，只是简单的执行一些操作。
*   `Task<T>`，当方法向调用者返回值时。在这种情况下，编译器将等到操作完成，然后将结果(一个`T`类型)返回给调用者。

让我们通过使用我们之前用来解释回调方法的同一个`Geolocator`类来看一个真实的示例代码。在这种情况下，我们不会订阅以跟踪用户的移动，但我们会使用名为`GetGeopositionAsync()`的方法(注意`async`后缀)请求一个单独的位置。

代码清单 81

```
  private async void OnGetPositionClicked(object sender, RoutedEventArgs e)
  {
      Geolocator geolocator = new Geolocator();
      Geoposition geoposition = await geolocator.GetGeopositionAsync();
      Latitude.Text =
  geoposition.Coordinate.Latitude.ToString();
      Longitude.Text =
  geoposition.Coordinate.Longitude.ToString();
  }

```

我们可以看到正确使用异步方法所需的两个关键特性。第一个是方法签名需要包含`async`关键字。然后我们可以在调用异步方法之前添加`await`前缀(在我们的例子中是`GetGeopositionAsync()`)。由于这个关键字，运行时将等到操作完成后再继续。结果是，在地理定位服务返回用户的位置之前，应用程序不会在页面上显示用户的坐标。

如您所见，这段代码的读写要简单得多，而且完全是异步的。该操作将在不同于管理用户界面的线程上执行，从而保持应用程序的快速响应。

重要的是要强调，作为一条规则，每个异步操作都需要返回一个`Task`或一个`Task<T>`对象。如果你声明一个简单返回`void`的异步方法，行为可能是不可预测的。唯一的例外是当您处理事件处理程序时(就像在前面的示例中)。由于它们是“火了就忘了”的方法(您不需要等到例如某个`Button`上的`Click`事件完成后再执行操作)，您可以将它们标记为`async` `void`。

例如，如果前面的示例代码是一个简单的方法，而不是一个事件处理程序，这将是编写它的正确方法:

代码清单 82

```
  private async Task GetPosition()
  {
      Geolocator geolocator = new Geolocator();
      Geoposition geoposition = await geolocator.GetGeopositionAsync();
      Latitude.Text =
  geoposition.Coordinate.Latitude.ToString();
      Longitude.Text =
  geoposition.Coordinate.Longitude.ToString();
  }

```

如您所见，该方法现在返回一个`Task` 对象，因此我们可以使用`await`前缀来调用它:

代码清单 83

```
  private async Task GetUserPosition()
  {
      await GetPosition();
  }

```

或者，如果您想编写一个简单地将检测到的位置返回给调用者的方法，而不是直接设置两个`TextBlock`控件的值，那么该方法应该如下所示:

代码清单 84

```
  private async Task<Geoposition> GetPosition()
  {
      Geolocator geolocator = new Geolocator();
      Geoposition geoposition = await geolocator.GetGeopositionAsync();
      return geoposition;   

  }

```

这次的不同之处在于，它返回的不是一个普通的`Task`对象，而是一个`Task<Geoposition>`对象。然后，您可以直接从调用方法更新`TextBox`控件，如下例所示:

代码清单 85

```
  private async void OnGetPositionClicked(object sender, RoutedEventArgs e)
  {
      Geoposition geoposition = await GetPosition();
      Latitude.Text =
  geoposition.Coordinate.Latitude.ToString();
      Longitude.Text =
  geoposition.Coordinate.Longitude.ToString();

  }

```

当您使用异步代码时，代码通常在多个线程上执行。这样，UI 线程可以自由地保持界面的快速和响应。但是，有时您需要从辅助线程与页面的控件进行交互。问题是，如果您尝试这样做，应用程序将崩溃，出现以下异常:

*应用程序调用了为不同线程封送的接口。
(来自 HRESULT 的异常:0x 8001010 E(RPC _ E _ error _ THREAD))*

出现此问题是因为您无法从后台线程与用户界面交互。但是，如果您使用异步和等待模式，则不必处理这个问题。该模式自动负责将结果从辅助线程返回到主线程。事实上，正如您在前面的示例中看到的，我们没有做任何特别的事情来在屏幕上显示用户的位置。我们简单地使用`GetGeopositionAsync()`方法检索坐标，并将结果分配给几个`TextBlock`控件的`Text`属性。

然而，您并不总是有机会使用异步等待模式。让我们考虑一下关于使用回调方法的前一个示例:

代码清单 86

```
  private void
  OnStartGeolocator(object sender, RoutedEventArgs e)
  {
      Geolocator geolocator = new Geolocator();

  geolocator.PositionChanged += geolocator_PositionChanged;
      Debug.WriteLine("Finding the user’s
  position…");
  }

  void geolocator_PositionChanged(Geolocator sender, PositionChangedEventArgs args)
  {
      Latitude.Text =
  args.Position.Coordinate.Latitude.ToString();
      Longitude.Text =
  args.Position.Coordinate.Longitude.ToString();
  }

```

前面的代码将在运行时生成一个异常。回调的方法实际上是在后台线程上执行的，而我们试图更新的`TextBlock`控件是由 UI 线程管理的。

对于这些情况，通用视窗平台提供了一个名为`Dispatcher`的类，负责将操作转发给用户界面线程。以下是定义上一个示例的正确方法:

代码清单 87

```
  private void
  OnStartGeolocator(object sender, RoutedEventArgs e)
  {
      Geolocator geolocator = new Geolocator();

  geolocator.PositionChanged += geolocator_PositionChanged;
      Debug.WriteLine("Finding the user’s
  position…");
  }

  void geolocator_PositionChanged(Geolocator sender, PositionChangedEventArgs args)
  {
      Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>
      {
          Latitude.Text =
  args.Position.Coordinate.Latitude.ToString();
          Longitude.Text =
  args.Position.Coordinate.Longitude.ToString();
      });
  }

```

需要在 UI 线程上执行的操作(在我们的例子中，将用户的位置分配给一个`TextBlock`控件的`Text`属性)被包装在一个匿名方法中，该匿名方法作为`Dispatcher`类公开的`RunAsync()`方法的参数传递。第一个参数代表操作的优先级:建议的通常是`Normal`。这样，整个回调的方法将在后台线程上执行，但是`RunAsync()`方法执行的操作将在用户界面线程上执行。重要的是继续`Dispatcher`只是真正需要与页面交互的操作。例如，如果我们在页面上显示坐标之前对用户的位置做了额外的操作(比如将坐标转换成市民地址)，我们应该在调度程序之外执行这些操作。

我们已经在本书的第一章看到了这个概念。由于视窗 10 引入了视窗即服务的概念，一台视窗 10 机器可以有多个版本的通用视窗平台，因为每次重大更新都会引入一个新的软件开发工具包版本，并带有一套扩展的应用编程接口和功能。

现在，当您在 Visual Studio 2015 中创建新的通用项目时，会出现以下对话框提示您:

![](../Images/image022.jpg)

图 22:在 Visual Studio 2017 中创建新的通用 Windows 平台应用程序时显示的对话框。

**目标版本**是指您希望在应用程序中利用的一组 API。例如，如果将**设定为目标，Windows 10 创作者更新(10.0；build 15063)** ，这意味着您还将能够访问这个版本中添加的新 API。

**最低版本**指你想支持的最低 Windows 10 版本。如果您将 Windows 10(10.0；build 10586) ，该应用也将在搭载 Windows 10 月更新的设备上运行。仍在使用原始 Windows 10 版本(版本 10240)的旧设备将无法安装此应用程序，无论是从商店还是手动加载。

选择最佳组合取决于您正在进行的项目类型。例如，假设您的应用程序严重依赖一个名为**应用程序扩展**的特性，这意味着您的应用程序可以充当扩展的容器。你可以把它们想象成可以给你的应用程序增加新特性的插件。这个特性已经被添加到周年更新中，如果没有它，你的应用程序将没有多大意义。在这种情况下，最好的选择是将分发限制在已经拥有周年更新的用户。因此，您将把**目标**和**最小**版本都设置为 SDK 14393。

另一方面，假设您有另一个依赖于 Composition APIs 的应用程序，它是我们将在本系列的下一本书中看到的一组类和方法。通过添加强大且高性能的动画，该套件有助于创建更好的用户界面。这些应用编程接口已经在 Windows 10 中引入，但在 11 月和周年更新中进一步扩展。然而，动画几乎不是一个核心特性，所以仅仅为了利用一些额外的动画而限制可以下载应用程序的用户数量并不是一个明智的选择。在这种情况下，将**最低版本**设置为 SDK 10586(这样我们就可以为更多的用户提供所有核心功能)和将**目标版本**设置为 SDK 15063 更有意义，这样，通过利用上一章中描述的 API 检测方法，我们仍然可以使用更新的设备向用户显示新的动画。

需要强调的一点是，API 检测方法只在 C#中有效，而不适用于 XAML。这意味着，如果您计划利用在 XAML 管理的一些周年更新功能，您不能根据操作系统的版本来过滤它们。在这种情况下，如果你想利用它们，你必须将**最低版本**和**目标版本**设置为同一个软件开发工具包。这个场景的一个真实例子是`x:Bind`标记表达式。正如我们在本章中所看到的，周年更新中增加了一些特性(如强制转换和函数支持)。即使您将 14393 SDK 设置为**目标版本**，直到**最低版本**设置为以前的版本，如果您试图利用这些新功能之一，您在编译项目时总是会遇到构建错误。