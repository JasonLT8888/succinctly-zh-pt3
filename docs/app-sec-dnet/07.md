# 七、对称加密

对称加密使用相同的密钥来隐藏和稍后揭示(加密和解密)秘密消息。考虑到这样一个简单的概念，包括 frameworks—.NET 在内的大多数国家未能提供简单、万无一失(即安全且能抵抗错误配置和滥用)的对称加密应用编程接口，这些应用编程接口可由需要基于共享密钥加密和解密数据的工程师(而非密码学家)使用。

然而，大多数框架确实提供了各种各样的加密原语，这些原语可以用来构建安全的对称加密应用编程接口，但实际上是用来创建破碎的、不安全的实现，从而提供虚假的安全感(直到您公司的数据成为新闻)。微软通过宣称以下内容来强化这种虚假的信心:“你不需要成为密码学专家就可以使用[ `System.Security.Cryptography` ]类。”这就像在说“你不需要知道驾驶规则，因为我们给了你一辆车。”像 NIST 这样的标准化机构是问题的一部分，因为它们为密码学家——而不是工程师——制定标准，这些标准由上述框架实施并向世界公开。

想象一下，NIST 告诉你，他们为你准备了一辆很棒的车，叫做 AES。它是安全的、经过批准的、经过时间考验的，并且使用安全。但是，发动机、制动器、变速箱、转向和悬架是分开的。一旦你想出如何正确地把所有东西放在一起——并且设法不搞砸编码机制——汽车应该可以安全驾驶。听起来怎么样？从技术上讲，AES 甚至不是那辆车，而是那辆车的发动机:一个分组密码。 [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) 本应是一种“高级加密标准”，但它未能成为一种标准。相反，AES 实际上是在三种定义的“强度”模式(10、12 或 14 个转换周期)中使用称为 Rijndael 的分组密码的规范。AES 应该是 ABCS 的“高级分组密码标准”

实际的对称加密是由块密码、链接模式、填充模式、初始化向量、随机数和认证加密模式组成的加密动物园，这只是基本的东西。你是否有信心[<sup>【1】</sup>](AppSecurity_0015.htm#_ftn1)能够正确地将所有事情组合在一起？你团队的其他人呢？

然而，不要害怕，因为 NIST 将再次为您服务，并提供友好的 [SP-800-38a](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf) AES 手册:22 页以上关于如何正确使用 AES 分组密码的建议。这就像问你的汽车经销商“启动汽车”的按钮在哪里，然后拿到一份关于“用双离合变速器连接直喷式双涡管涡轮发动机”的技术手册...用德语。[二重奏](https://www.google.com/#q=Doppelkupplungsgetriebe)？

为了安全驾驶汽车，你不必是一名发动机机械师。你不一定要成为营养师才能吃得健康。使用共享密钥加密和解密消息时，您不应该必须是密码学家。

本节的目标是提供简单的规则，以实现安全的实现，并防止您创建另一个破碎的排列来破坏对称加密烧焦的雷区。下一章[“认证加密”](08.html#_Chapter_8_)是对称加密实际上变得安全的地方，但是我们首先需要一个加密原语。

## AES

如果您不是密码学家，AES 分组密码是您应该放心使用的唯一分组密码。这就引出了一个简单的第一条规则:永远使用 AES，忘记框架附带的任何东西。AES 有三种不同的“强度”模式，通常没有直接设置，而是通过使用特定的 AES 密钥长度来设置。AES 算法基本上是相同的，但是更高的“强度”模式只是执行更多轮的算法。

表 5:不良事件强度水平的比较

|  | AES-128 | AES-192 | AES-256 |
| --- | --- | --- | --- |
| 分组密码长度(所有模式相同) | 128 位 | 128 位 | 128 位 |
| 密钥长度 | 128 位 | 192 位 | 256 位 |
| 巡视 | Ten | Twelve | Fourteen |

AES-256 比 AES-128 更强，因为它还有四轮——不是因为它碰巧使用了一个更长的密钥，因为一个全熵的 128 位密钥对于所有看似合理的目的来说已经足够强了。那个。NET Framework 在`AesManaged`和`AesCryptoServiceProvider` (FIPS 批准的)类中提供了两种 AES 实现。

托管 AES 类实例的创建速度比 FIPS 同类产品快约 170 倍，处理数据的盈亏平衡点约为 2.8k。如果您总是加密不到 2.8k 的数据，托管 AES 可能会快一点；否则，使用 **AES-CSP** 实现(这是我们大多数时候用于 FIPS 合规性的)。您应该使用哪种 AES:AES-128、AES-192 或 AES-256？它们的加密和解密速度通常与回合数成正比——您可以估计 AES-256 比 AES-128 慢 40%左右。然而，只有当 AES 处理足够长的消息时，您才会感受到算法性能差异的全部程度。在大多数现代系统(包括现代移动平台)上，AES 风格之间的性能差异不太可能成为问题。

可用的 AES 实施默认值是另一个重要的决策因素。这两种微软实现都默认为 AES-256，这意味着如果你想使用 AES-128 或 AES-192，你将不得不不断与默认值作斗争。接受微软的默认选择更有意义。由于公制和英制不匹配，美国宇航局损失了一个价值 1.25 亿美元的火星轨道器——不要以为你总能记住改变默认值。

如果你仍然不相信 AES-256 是正确的道路，这里有一段引用自 [LibTomCrypt](http://www.libtom.net/) (C 语言密码库):

理想情况下，您的应用程序应该至少有 256 位密钥。这不是因为你要偏执。这是因为如果你的 PRNG 有任何类型的偏见，越多越好。例如，如果您有 Pr [X = 1] = bias，其中|bias| > 0，则 N 位中的熵总量为 N *(log<sub>2</sub>(+| bias |))。因此，如果偏差为 0.25(严重偏差)，一个 256 位的密钥将有大约 106 位的熵，而一个 128 位的密钥将只有 53 位的熵。

以下是著名密码学专家丹尼尔·伯恩斯坦的另一句名言:

但是 NIST 愚蠢地继续推荐 AES-128 密钥，尽管 2 <sup>80</sup> 攻击会从一批 2 <sup>48</sup> 密钥中破坏某人的 AES-128 密钥。

| ![](img/tip.png) | 提示:只需使用 AES-256 即可。 |

## 键

AES 实现有一个公共的`.Key`属性，可以用来获取或设置`byte[]`类型的密钥。该公共属性由一个私有容器支持，该容器最初为空。`.Key` getter 将在私钥容器为空时生成一个新的加密强密钥，或者在密钥容器不为空时简单地返回一个现有密钥。这实际上是按需生成密钥，从而加快了 AES 实例的构建。可以通过`.GenerateKey()`方法明确触发密钥的生成或重新生成。您也可以使用加密的强 RNG 从外部生成密钥，并直接将其分配给`.Key`属性。外部生成的 AES 密钥的唯一技巧是确保它们具有正确的大小。如果您采用 AES-256 来满足所有需求，外部密钥生成将变得非常简单—只需从基于 CSP 的 RNG 获得 32 个字节。我们也要再次强调一个显而易见的点，密匙就是*秘密*。不要在邮件中包含密钥。不要散列，HMAC，异或，盐，或油炸它们，使它们的任何部分非秘密，否则你会失败。保守秘密钥匙和任何从钥匙衍生出来的东西的秘密。

## 密码模式

像 AES 这样的分组密码对单个分组进行操作，在 AES 的情况下，该分组是 16 字节长。[密码模式](http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation)用于使分组密码处理可能不适合单个块的任意长度的消息。唯一一个你可以自己编写的 AES 密码模式是 CBC。CBC 是中托管和 FIPS AES 实现都支持的唯一密码模式。NET 框架，也是默认模式。接受默认设置。

## 填充模式

像 AES 这样的分组密码对完整的分组进行操作，但是并不是每条消息都是块大小乘以长度的。最后一个块往往可以是不完整的，可以使用各种[填充模式](http://en.wikipedia.org/wiki/Padding_(cryptography))使最后一个不完整的块完整。一些密码模式不需要填充，但许多——包括 CBC 需要。您需要记住的重要一点是，使用 CBC 选择哪种填充模式并不重要，因为它们都用作可逆填充，并且都不安全(至少是中可用的那些)。NET 框架)。我们将通过认证加密来解决填充模式的不安全性，但是我们还没有做到。因为使用哪种填充模式并不重要，所以您不妨使用默认模式，即。NET AES 实现恰好是 PKCS7。

## 初始化向量(四)

**初始化向量(IV)** 是 AES 等分组密码使用的额外的非秘密熵块，用于防止由于密钥重用和明文重用而导致的漏洞(如密文模式)，这两种情况都非常常见和常见。我们通常期望能够使用相同的密钥来加密多条消息，并且我们通常期望能够在不同的时间点加密相同的消息，而不会暴露消息的“相同性”。分组密码四是一个块长(AES 为 16 字节)。不同的密码模式对静脉注射的内容有不同的要求。幸运的是，我们只需要知道 CBC 的ⅳ要求，因为这是我们自己编码的密码模式。

| ![](img/tip.png) | 提示:对于加密过程的每次执行<u>，CBC IV 必须是不可预测的。</u> |

这里的“不可预测”是指“由总部位于 RNG 的 CSP 生成。”还要注意“每次执行”部分:如果你以任何方式偏离这个 CBC IV 要求，你就失败了。如果你试图通过散列、散列、HKDFing 或以某种方式导出它来变得“聪明”——只是为了避免将静脉注射与加密消息一起发送——你就失败了。如果你忘记了“每次执行”的要求，重复使用静脉注射——你就失败了。给定这样一个简单且易于实现的 CBC IV 需求，令人惊讶的是有多少实现会出错。一位微软“开发者安全”MVP(最有价值专业人士)搞错了。

AES 实现有一个`.IV`属性，它的工作方式类似于`.Key`属性，也可以“按需”生成基于 CSP 的随机 IV。静脉注射的生成或再生成可以通过`.GenerateIV()`方法明确触发。您也可以使用基于 CSP 的 RNG 从外部生成 IV，并将其直接分配给`.IV`属性。如果您采用外部方法，请记住 AES IV 大小始终为 16 字节。一旦您使用新生成的随机 IV 执行了 AES 加密操作，您需要将该 IV(这不是秘密)包含在密文中，以便以后可能进行解密过程，并且您永远不应该将该 IV 用于任何其他加密操作。

## 计数器模式下的 AES(CTR)

而 CBC 模式是中最安全、防误用的内置密码操作模式。NET，对于高级使用场景来说，它不是最安全或最方便的模式，例如设计更复杂的加密结构，使用可变长度数据加密作为构造块。Counter ( [CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation) )模式是另一种非常受欢迎的模式，它在技术上优于 CBC 模式(但不具有抗误用性)，并且更适合作为其他更复杂的加密方案中的数据加密组件。[著名密码学专家菲利普·罗加威](https://en.wikipedia.org/wiki/Phillip_Rogaway)对 CTR 模式有如下评价:

我想不出任何密码设计问题，在没有主要遗留考虑的情况下，任何[CBC 和其他经典模式]将代表选择的模式……我认为 CTR 很容易成为一组保密模式中的最佳选择(这意味着一组模式只针对消息隐私，正如经典理解的那样)。它具有无与伦比的性能特征和可证明的安全性保证，至少与任何(其他经典)模式在经典隐私概念方面一样好。CTR 的简单、高效和明显的正确性使其成为任何现代[安全]方案组合中的强制成员。

由于您不应该设计任何与加密相关的东西，所以不要试图自己实现 CTR，并坚持使用内置的 CBC。不过，体面一点。CTR 模式的 NET 实现可在[地狱](http://securitydriven.net/inferno/)加密库中获得(不是放弃 CBC 的有效理由)。