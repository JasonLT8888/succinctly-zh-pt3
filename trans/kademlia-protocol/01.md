# 一、引言

卡德姆利亚，根据邢和吕克·德沃尔在 2015 年发表的论文[<sup>【1】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn1)，是“互联网上 P2P(点对点)网络事实上的标准搜索算法。”Kademlia 是一个协议规范，用于分散对等网络操作，在网络上高效地存储和检索数据。

对等网络有几个积极的方面:

*   它是分散的，这意味着数据不存储在中央服务器上，而是冗余地存储在对等服务器上。
*   它是容错的，这意味着如果一个或多个对等体退出网络，存储在多个对等体上的数据仍然应该是可检索的。
*   不需要复杂的数据库引擎——存储在 P2P 网络上的数据通常存储在键值对中，这使得它甚至适合存储有限的物联网设备参与网络。

卡德姆利亚是由佩塔尔·梅穆恩科夫和大卫·马齐尔斯在 2002 年设计的。维基百科这样描述卡德姆利亚:

“它规定了网络的结构和通过节点查找进行的信息交换。Kademlia 节点之间使用 UDP 进行通信。虚拟或覆盖网络由参与节点形成。每个节点都由一个编号或节点标识来标识。节点标识不仅用作标识，而且卡德姆利亚算法使用节点标识来定位值(通常是文件哈希或关键字)。事实上，节点标识提供了文件哈希的直接映射，该节点存储了从哪里获取文件或资源的信息。”[<sup>【2】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn2)

## 谁用卡德姆利亚？

Kademlia 用于文件共享网络。例如，BitTorrent 8 使用基于 Kademlia 算法实现的分布式哈希表(DHT)。Kad 网络 9 使用 Kademlia 协议，eMule 是一个开源的 Windows 客户端。

## 卡德姆利亚为什么重要？

不仅仅是加密货币，任何区块链的底层技术，包括那些实现智能合约的技术，[<sup>【3】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn3)都必须包含一个 P2P 分布式哈希表，至少在区块链技术如何被讨论和应用方面是如此。(在集中式场景中使用区块链有点毫无意义，除了用于日志记录的目的。)了解 P2P 协议如何工作很重要，因为区块链是那些已经并将继续对软件应用程序开发产生影响的革命性技术之一。

许多人认为，除了性能方面的原因，集中式数据已经过时了。[<sup>【4】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn4)正如最后一个环节所说:“数据管理行业整合得越多，分散市场的对立力量就越多。”对等分散化内置了冗余，可以防止单点数据丢失和访问失败。并不是说去中心化没有它自己的问题——安全可能是主要的问题，如果还没有的话。

认识到有一些有趣和复杂的密码货币和区块链技术即将到来，并且这些技术需要被理解，像卡德姆利亚这样的协议是研究任何 P2P 分布式哈希表实现的一个很好的起点。至于为什么是卡德姆利亚，卡德姆利亚规范的总结说得最好:

“凭借其新颖的基于 XOR 的度量拓扑，Kademlia 是第一个将可证明的一致性和性能、延迟最小化路由以及对称单向拓扑相结合的对等系统。Kademlia 还引入了一个并发参数α，让人们可以用恒定的带宽因子来换取异步最低延迟跳数选择和无延迟故障恢复。最后，Kademlia 是第一个利用节点故障与正常运行时间成反比这一事实的对等系统。”

## 这个名字从何而来？

正如卡德姆利亚的联合创作者之一佩塔尔·梅穆恩科夫所说:“这是土耳其语中‘幸运儿’的意思，更重要的是，这是保加利亚一座山峰的名字。”

## 对现有实现的关注

在仔细研究 GitHub 存储库的过程中，我发现了许多不完整或明显有问题的实现，通常只需检查代码就可以发现。更复杂的是，似乎有两种不同版本的卡德姆利亚协议。一个是很短的规范，省略了很多关于路由表和性能改进的讨论，而麻省理工学院网站上较长的规范[<sup>【5】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn5)显然是“正确”的版本。较短的规范似乎已从莱斯大学网站上删除。

两个实现是很好的参考:

*   Zen coders[<sup>【6】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn6)是一个 C#实现，它似乎基于较短的规范，似乎与 Jim Dixon 对算法的描述[<sup>【7】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn7)相匹配。
*   Brian Muller 在 Python 中有一个基于较长规范的出色实现。[<sup>【8】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn8)

审查开源实现时，建议您检查代码，以验证它实现了较长规范中描述的优化。

## 其他语言

除了 C#和 Python，我没有仔细研究过其他语言的实现。还有许多其他语言的实现，主要是用 Java、Javascript 和 Go 编写的。简单地看一下这些其他语言的实现，很容易知道它们实现的是规范的哪个版本，因此，再次注意，根据使用的规范，您可能会有非常不同的实现。例如，Java 中的一个实现制定了一个规范中没有的关于桶拆分的非常具体(但看似任意)的规则。

## 要求

本书中实现的代码需要:

*   C# 7
*   。NET 框架 4.7
*   Visual Studio 2017

强烈推荐了解 LINQ 的工作知识。

## 写这本书用到的资源

我在这本书的研究中使用了几个资源:

*   [迈克·德波尔对 k 桶的描述](https://github.com/mikedeboer/node-k-bucket)
*   [布莱恩·穆勒的 Python 实现](https://github.com/bmuller/kademlia)
*   [zencoders 的实现](https://github.com/zencoders/sambatyon/tree/master/Kademlia/Kademlia)
*   [吉姆·迪克森关于两个不同版本规范的帖子](https://www.mail-archive.com/p2p-hackers@lists.zooko.com/msg00039.html)
*   [吉姆·迪克森对较短规格的描述](http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#FIND_NODE)
*   [吉姆·迪克森对规范第 2.4 节](https://www.mail-archive.com/p2p-hackers@lists.zooko.com/msg00042.html)的描述
*   [Kademlia 分布式哈希表的实现](http://pub.tik.ee.ethz.ch/students/2006-So/SA-2006-19.pdf)，瑞士苏黎世联邦理工学院 Bruno Spori 撰写的学期论文
*   分布式哈希表和自组织网络，麻省理工学院乔纳森·佩里讲座

## 推进这项工作的其他资源

如果您感兴趣，可以在这里找到一些额外的资源来进一步研究 P2P 系统、性能、分布式分类账和安全性:

*   [IPFS–内容寻址、版本、P2P 文件系统](https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf)(草案 3)
*   [S/Kademlia:一种可行的基于密钥的安全路由方法](https://pdfs.semanticscholar.org/0219/0db89bf2d898817aa600c3edca6ded294de0.pdf)
*   [通过广泛部署的分布式哈希表提高查找性能](http://www.barsoom.org/papers/infocom-2006-kad.pdf)
*   [网络中 Sybil 攻击的检测与缓解综述](https://tinyurl.com/y9a7ekzy)，Procedia 计算机科学 78 (2016) 395-401
*   [流程链:构建物联网区块链的案例研究](http://schd.ws/hosted_files/lc3china2017/43/Flowchain-LC3_2017_Beijing-20170614.pdf)
*   英国政府首席科学顾问的报告《分布式分类账技术:超越区块链》

## 卡德姆利亚没有解决的问题

Kademlia 规范讨论了对等体如何通信、查找对方以及共享和检索数据。创建 P2P 网络时，仍有许多问题需要解决。以下是一些主要问题的列表(术语和问题将在以后变得更加清晰，因此在完成材料后，请考虑回到这一部分):

*   键值中的密钥冲突:虽然不太可能，但缓解这种情况的最好方法是让您自己的对等方为您创建一个随机密钥。
*   对等标识冲突:同样，应该为您创建节点标识。
*   值的加密。
*   密钥的隐私性:虽然在当今的技术下不实用，但是恶意的对等方可以在整个 2 <sup>160</sup> 密钥空间中查询存储的值。
*   通过网络发送的数据包的序列化格式。
*   能够根据值长度限制对等方存储的内容。
*   私有对等组:加入公共 P2P 网络，但在网络中创建私有对等组。
*   部分参与:如果您想参与存储和检索键值的对等网络，但不想自己存储键值，该怎么办？也许您运行的是存储有限的物联网设备？
*   从同一个网络地址注册多个对等体标识:这是一个特别值得关注的问题，因为您可以使用它来降低对等体的性能，如“降低卡德姆利亚对等体的性能”一节所述
*   当对等体将值传播给其他对等体时，对该值进行篡改:这可以通过包含公钥来确保该值没有被更改来补救。虽然说“对等”很奇怪，但当你下载了一个对等应用程序，但你不知道里面发生了什么时，这就成了一个问题——即使你有源代码，你知道去哪里找吗？

## 这里完成了什么

本书的目标是详细讨论卡德姆利亚规范的实现。具体而言，我们将:

*   带实现的地图规范
*   发现与规范相关的任何领域
*   抽象设计的关键领域，以便:

*   可以选择不同的实现方式
*   可以使用不同的通信协议
*   该算法可以很容易地进行单元测试

## 关于单元测试

一些单元测试为测试代码设置了特定的条件。其他人使用随机生成的标识(节点标识和密钥)，并通过同一算法的不同实现来验证结果。为了确保这些测试的可重复性，`Random`类在调试模式下以相同的值播种，并作为公共静态字段公开，以便一些单元测试可以用一系列种子执行它们的测试。

代码清单 1:单元测试的随机播种

```cs

  #if DEBUG
   public static Random rnd = new Random(1);
   #else
   private static Random rnd = new Random();
   #endif

```

此外，大多数单元测试实际上是系统级测试，或者至少是部分系统测试。对于特定方法中特定代码段的实际单元测试，它会很快变得空洞。因此，您将看到在更高级别的测试中完成了许多设置工作。

本书中介绍的单元测试之所以重要，不仅仅是因为它们测试了底层实现，还因为它们演示了如何在特定条件下设置测试卡德姆利亚协议的场景。彻底理解单元测试可能是理解 Kademlia 协议的一种比查看实现更好的方式！

## 关于代码的一句话

这里呈现的代码是增量式的，这意味着随着附加特性的讨论和添加，代码会更新以反映这些新特性及其单元测试。不是每个重构都包含在这里的代码中；因此，强烈建议如果您对某个特定的方法感兴趣，可以在实际的代码库中查看最终的实现。

代码库的 GitHub 存储库可以在这里找到[。](https://github.com/SyncfusionSuccinctlyE-Books/The-Kademlia-Protocol-Succinctly)

## 参考卡德姆利亚规范

这本书包含了规范[卡德姆利亚:基于异或度量的对等信息系统](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)的大量摘录。这些在斜体的文本中清楚地表示为“引用的”*。*