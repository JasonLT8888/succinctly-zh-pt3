# 二、关键概念

卡德姆利亚规范由几个子算法组成:

*   注册新的对等方
*   更新对等列表
*   获得与密钥“最接近的对等体”(这个概念将在后面详细讨论)
*   存储和检索键值
*   管理过时的键值对和对等项

代码中最复杂的部分是在注册新的对等点，因为这涉及到一些基于 Kademlia 作者对其他网络性能研究的神奇数字，如 Chord[<sup>【9】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn9)和 Pasty、[<sup>【10】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn10)以及这些网络中对等点的行为。

## 卡德姆利亚术语

这里描述了卡德姆利亚规范中专门使用的术语。

**覆盖网络**:覆盖网络是指每个节点保存一份(通常是部分)参与网络的其他节点的列表。

**节点**:节点(也称为联系人)是网络中的对等体。

**节点 ID** :这是一个 160 位的节点标识符，从某个密钥的 SHA1 散列中获得，或者是随机生成的。

**k-Bucket** :最多 k 个节点(或联系人)的集合，也简称为 Bucket。每个节点最多处理一个标识范围内的 *k* 个联系人。最初，标识范围是从 0 < =标识< = 2 <sup>160</sup> - 1 的整个光谱。

**键值**:对等体基于 160 位 SHA1 哈希键存储值。每个存储的条目由一个键值对组成。

**路由器**:路由器管理 k 个桶的集合，还决定键值应该存储到哪些节点。

**距离/接近度**:主机与密钥之间的距离是主机 ID 与密钥的异或运算。卡德姆利亚最重要的特征是使用这种异或计算来确定标识之间的距离/接近度。

**前缀**:前缀是用来描述 ID 的 *n* 最高有效位(MSB)的术语。

**深度**:桶的深度定义为桶的共享前缀。因为铲斗与从 2 <sup>i</sup> 到 2 <sup>i+1</sup> - 1 的范围相关联，其中 0 < = i < 160，所以可以说铲斗的深度是 160 - i。我们稍后会看到，情况可能并非如此。

**桶分裂**:当一个节点的 k-bucket 满了(这意味着它有 *k* 个触点)并且一个具有给定 160 位密钥的新触点想要在该密钥的桶范围内注册时，桶分裂可能会发生。在这一点上，一个算法开始发挥作用:

*   在一种情况下，会将范围中点处的存储桶分成两个范围，将联系人放入适当的新存储桶中。
*   在第二种情况下，当满足特定深度限定符时，拆分桶。
*   在第三种情况下，用该存储桶的“待处理”队列中的最新联系人替换不再响应的对等方。

## 通信协议

Kademlia 协议由四个远程过程调用(RPc)组成。所有 RPC 都要求发送方提供一个随机的 RPC ID，接收方必须回显:*“在所有 RPC 中，接收方必须回显一个 160 位的随机 RPC ID，这样可以提供一定的抗地址伪造能力；还可以在 RPC 回复上附带 PINGS，以便 RPC 接收方获得发送方网络地址的额外保证。”*

每当对等方与四个 RPC 中的任何一个联系时，它都会在自己的列表中添加或更新联系人。“亲密度”的概念将在后面详细讨论。

### 砰

*“PING RPC 探测一个节点，看它是否在线。”*这被认为是一个“原始”函数，因为它只是返回伴随`Ping`请求的随机 RPC ID。

### 商店

`STORE`指示节点存储一个(键，值)对，以便以后检索。这也被认为是一个“原始”函数，因为它再次返回伴随`STORE`请求*的随机 RPC 标识。"为了存储一个(密钥、值)对，一个参与者找到 k 个最接近密钥的节点，并把它们发送到 STORE RPCS . "*参与者通过检查其自身与密钥最接近的 k 个节点来做到这一点。

### 查找节点

" *FIND_NODE 以一个 160 位的 ID 作为参数。RPC 的接收者返回(IP 地址、UDP 端口、节点标识)它所知道的最接近目标标识的 k 个节点的三倍。这些三元组可以来自单个 k 桶，或者如果最近的 k 桶未满，它们可以来自多个 k 桶。在任何情况下，RPC 接收者都必须返回 k 个项目(除非在其所有 k 个桶中有少于 k 个节点，在这种情况下，它返回它知道的每个节点)。*”

在抽象的通信协议中，接收者需要返回关于协议的信息:协议的种类以及使用该协议联系对等方所需的任何东西。如果支持多种协议，我们可以考虑两种选择:

*   只返回请求者表示支持的协议的节点信息。
*   或者(也不是很好的选择)，请求者可以过滤掉协议不受支持的返回节点。

支持多种协议时的其他注意事项包括:

*   对等体本身可能支持多种协议，因此当它向另一个对等体注册时，它可能应该指出这些协议是什么。
*   对等体可以具有优选的协议。

规范中没有讨论不同协议的任何问题——这纯粹是我自己的改进。

`FindNode`协议有两个目的:

*   对等体可以在它知道的联系人上发出这个 RPC，更新它自己的“亲密”对等体列表。
*   对等体可以发出这个 RPC 来发现网络上的其他对等体。

### 查找值

*“FIND _ VALUE”的行为类似于 FIND _ NODE——返回(IP 地址、UDP 端口、节点 ID)三个三元组——只有一个例外。如果 RPC 接收方收到了密钥的 STORE RPC，它只返回存储的值。*

如果`FindValue` RPC 返回了一个其他对等体的列表，则由请求者继续从该列表中搜索所需的值。另外，请注意缓存键值的技术:

*“为了找到(键、值)对，节点首先执行查找，以找到 id 最接近键的 k 个节点。但是，值查找使用查找值而不是查找节点 RPCS。此外，当任何节点返回值时，该过程会立即停止。出于缓存目的，一旦查找成功，请求节点会将(键、值)对存储在它观察到的与未返回值的键最近的节点上。”*

### 其他考虑因素

#### 到期时间

*“此外，每个节点根据需要重新发布(键、值)对，以使它们保持活动状态，如第 2.5 节后面所述。这以非常高的概率确保了(键、值)对的持久性(如我们在证明草图中所示)。对于 Kademlia 当前的应用程序(文件共享)，我们还要求(密钥、值)对的原始发布者每 24 小时重新发布一次。否则，(键、值)对将在发布后 24 小时过期，以限制系统中过时的索引信息。对于其他应用程序，如数字证书或加密哈希值映射，较长的到期时间可能是合适的。”*

如果我们想考虑在分布式分类帐实现中使用卡德姆利亚，似乎有必要让键值永不过期——否则，这将导致分类帐数据的完整性损失。

#### 过度缓存

*“由于拓扑的单向特性，未来对同一关键字的搜索很可能会在查询最近的节点之前命中缓存条目。在某个密钥非常流行的时候，系统可能会在许多节点上缓存它。为了避免“过度缓存”，我们使任何节点的数据库中的(键、值)对的到期时间与当前节点和其 id 最接近键 ID 的节点之间的节点数量成指数反比。虽然简单的 LRU 驱逐会导致类似的生存期分布，但没有选择缓存大小的自然方法，因为节点不知道系统将存储多少值。”*

#### 桶已刷新

*“桶通常由通过节点的请求流量保持新鲜。为了处理没有针对特定标识范围的查找的病理情况，每个节点刷新在过去一小时内没有对其执行节点查找的任何存储桶。刷新意味着在存储桶的范围内选择一个随机标识，并对该标识执行节点搜索。”*

#### 加入网络

*“要加入网络，节点 u 必须与已经参与的节点 w 有联系。u 将 w 插入适当的 k-bucket。然后，u 为自己的节点 ID 执行节点查找。最后，u 刷新比它最近的邻居更远的所有 k 桶。在刷新过程中，u 既填充自己的 k 桶，又根据需要将自己插入其他节点的 k 桶。”*