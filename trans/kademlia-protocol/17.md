# 结论

佩塔尔·梅穆恩科夫写道...我的观点是，卡德姆利亚是如此简单，以至于用 Go 这样的现代语言，卡德姆利亚的一个好的实现(算法)不超过 100 行代码。”[<sup>【19】</sup>](The_Kademlia_Protocol_Succinctly_0020.htm#_ftn19)也许仅从算法(尤其是路由器)来看，这可能是正确的，但有大量的细节必须深入到卡德姆利亚协议的架构和实现中。随着对规范的深入研究，两个版本之间、野外的实现和规范之间都存在矛盾，必须通过仔细理解规范并仔细检查协议的其他实现和描述来解决许多歧义。任何采用实现卡德姆利亚协议的库的人都应该对这些矛盾和歧义有透彻的理解，并且还必须仔细梳理任何实现，看看这些是如何解决的——如果它们被解决的话。特别是，当查看其他实现时，实现是否(没有特别的重要性顺序):

*   地址延迟驱逐？
*   创建固定存储桶(每个前缀一个)还是动态存储桶？
*   通过异步行为提高性能？
*   不仅处理无响应的对等体，还处理对等体生成的异常等。？
*   提供足够合理的文档将代码与规范联系起来？
*   解决本地存储、缓存存储和远程存储更新之间的差异？
*   允许不同的协议？
*   解决西比尔攻击？
*   提供实施及其性能的详细单元测试和分析？

这些是我们应该寻找的一些问题。即使在这个实现的初始版本中，我也没有解决所有这些问题。无论如何，如果你已经做到了这一步，我怀疑你对卡德姆利亚协议有了更好的理解，这也给了你一些观察其他 P2P 协议的工具。